	.TITLE	LUNINT
;
;DIAGNOSTICS
;
	.RADIX	16
	.CSECT
	.GLOBL	NMI,PWRON,STEST,PWRINT,RAMTST,VRAMCLR,VRAMTST,ROMTST
	.GLOBL	D.SWTH,D.TEST,D.DIAG,RMCHAR,ROMDSP,D.FEND,D.FRME,D.DELY
	.GLOBL	D.NEXT,LOADRAM,LODRM8,LODRM2,LODRM4,LDRAM,SCRLDO,SCRLOAD,SCRLD1,LDRAM4
	.GLOBL	L.LED,S.SND,SCRLD2,DIGITS,DIGT2S,DIGTYS,DECIMAL,DECCNV,BMNBLK

	.GLOBL	DIAG1,DIAG2,DIAG3,DIAG4,DIAGTBL,DTBLOFF

	.GLOBL	LEDS,VGON,TESTSW,NOISE,POTIN,STARTSW,WATCH,ENGMSG,E.MOFF

	.GLOBL	RAMPTR,RAMLD,POINTR,TSFLAG,SWITCH,OLDSW,POTVAL,POTMIN
	.GLOBL	TEMP1,TEMP2,TEMP3,INDEX,TEST,ARRWX,ARRWY,$LMTIM,OFFSET
	.GLOBL	SOFT.0,SOFT.1,VGCOUNT,D.SCNT,PTRTMP,LAMPZP,NOISZP
	.GLOBL	PTRNGE,POTUSE,INTCNT,INTFLG,GAMODE,TIMVAL,TIMER,FLMIN
	.GLOBL	GMTIME,VGCOUNT,TEMP6,NUMB1,NUMB2,NUMB3,LABPTR,LANG,FRAME,C.OPT,M2.OPT
	.GLOBL	DELX,DELY,SCROLL,SCRADD

	.GLOBL	START,DSPLAA,VGHEXZ,VGADD,MOOLAH,DSPATTR,MESSAGE,MESSRG,MESSFU,MESSLAB,C.MEC2

	.GLOBL	INITSTK,SOFTWD,FRMECNT,CNCNTR,FLFACT,SECCNT,NCNCNTR
;
	VGRAM	=^H4000		;VG RAM START
	VGROM	=^H4800		;VG RAM START
;
	FINI	=^H4BDE		;BEAM REST LABS & HALT
;
	MSSGLBS	=550C		;MESSAGE LABS' TABLE
	WAIT7	=55AE
	VGMSGA	=57A2
;
	FTBLNG	=5800		;FOREIGN LANGUAGES'S TABLE OFFSET(S)
	FORMSG	=FTBLNG+4	;FOREIGN LANGUAGE POINTERS
	F.MIDX	=5FA1		;TABLE OFFSETS FOR F.MOFF
	F.MOFF	=5FA4		;FOREIGN MESSAGE OFFSETS
;
	MINTST	=4
	LASTST	=3		;NUMBER OF VG DIAG TESTS
;
OPT0	=2800
OPT1	=2801
OPT2	=2802
OPT3	=2803
;
	.SBTTL	.ASCVG - VG MODIFIED 'ASCII'
;
;MACRO .ASCVG CONVERTS STRING OF ALPHANUMERICS TO OFFSET VALUES INTO
;VGMSGA TABLE (TABLE OF VG CHARACTER JSRL'S)
;
	.MACRO .ASCVG .STRING
	.NCHR ..N,<.STRING>
	.IRPC ..C,<.STRING>
	.IF EQ,''..C-^H20
	..X=0			;BLANK CHAR=0
	.IFF
	.IF GT,''..C-^H40
	..X=''..C-^H36		;ALPHA'S ^B TO ^25
	.IFF
	..X=''..C-^H2F		;NUMBERS 1 TO ^A
	.ENDC
	.ENDC
	..X=..X*2		;..X=VGMSGA TABLE OFFSET
	..N=..N-1
	.IIF EQ,..N,..X=..X!^H80
	.BYTE ..X
	.ENDR
	.ENDM
	.LIST	MEB
	.NLIST	BYT
	.PAGE
	.INCLUDE VECMAC
	.TITLE	LUNINT - LUNAR LANDER INTERRUPT
	.SBTTL	PROGRAM SOUNDS, LEDS
;
;	SET UP SOUNDS
;	ACC = AND VALUE, X = ORA VALUE
;
S.SND:	AND	NOISZP		;AND W/MASK
	STX	TEMP6		;TEMP6 = ORA MASK
	ORA	TEMP6
	STA	A,NOISE		;SET SOUND
	STA 	NOISZP		;UPDATE ZP SOUND PORT STATUS
	RTS
;
L.LED:	AND	LAMPZP		;AND W/MASK
	STX	TEMP6		;TEMP6 = ORA MASK
	ORA	TEMP6
	STA	A,LEDS		;SET LEDS
	STA	LAMPZP		;UPDATE ZP LED PORT STATUS
	RTS
;
C.MEC2:	LDA	A,OPT3		;COIN MECH #2 SELECT
	AND	I,3
	TAX			;X = TABLE OFFSET
	LDA	AX,CM2TBL	;ACC = MECH #2 COIN SELECT
	STA	M2.OPT		;M2.OPT = MECH #2 COIN SELECT
	LDA	A,OPT2		;CHK LANG
	AND	I,3
	BEQ	2$		;BRANCH-ENG
	LDX	A,VGROM+1000
	INX			;CHK-FOREIGN ROM
	BNE	2$
	LDA	I,0		;DEFAULT-ENGLISH
2$:	STA	LANG		;SET LANGUAGE
	LDA	A,OPT0		;ASSUME OPTION 1 TO 4
	AND	I,3
	TAX
	INX
	LDA	A,OPT1		;CHK OPTION 0 (FREE PLAY)
	LSR
	BCC	5$		;BRANCH - NOT OPT 0
	LDX	I,0		;ELSE - OPTION 0
5$:	TXA
	ASL
	STA	C.OPT		;C.OPT = 2 * COIN OPTION
	RTS
;
;COIN MECH #2 OPTIONS
;
CM2TBL:	.BYTE	1,4,5,6
;
;DISPLAY ATTRACT MESSAGE
;
DSPATTR:LDX	I,12.		;LABS FOR MESSAGE (NO FLASH)
	LDA	C.OPT		;ACC=COIN OPTION (* 2)
	LSR
	CLC
	ADC	I,24.		;GET C.OPTION MESSAGE #
	JSR	MESSAGE		;LOAD LABS, WAIT & MESSAGE
	LDA	I,23.
	JSR	MESSRG		;DISPLAY FUEL UNITS
	LDA	I,5
	JSR	MESSRG
	LDA	FRAME
	AND	I,20		;FLASH 'INSERT COINS'
	BEQ	20$
	LDX	I,0		;LABS OFFSET
	LDA	I,4		;'INSERT...'
10$:	JMP	MESSAGE		;LOAD LABS, WAIT & MESSAGE
20$:	RTS
;
;	CONVERTS HEX INTO DECIMAL - 2 BYTE HEX IN X & Y
;	RESULT IN NUMB3,NUMB2,NUMB1
;
;
;	ROUTINE FOR FAST 16-BIT BINARY TO 6 DIGIT CONVERSION
;	INPUT:	X=MSB'S, Y=LSB'S
;	OUTPUT:	A=LSD'S, X=MIDDLE, Y=MSD'S
;	774. CYCLES WORST (AND BEST) CASE FOR 16. BITS
;
DECIMAL:STY	TEMP1		;TEMP1+1,TEMP1 = BINARY WORD
	LDY	I,15.		;BIT COUNT
DECCNV:	STX	TEMP1+1
	LDA	I,0
	STA	NUMB1		;CLR DECIMAL BYTES
	STA	NUMB2
	STA	NUMB3
	SED			;SET DECIMAL MODE
10$:	ASL	TEMP1
	ROL	TEMP1+1		;SHIFT A BIT OUT OF THE BINARY WORD
	LDA	NUMB1
	ADC	NUMB1
	STA	NUMB1		;AND ADD INTO DECIMAL BYTES
	LDA	NUMB2
	ADC	NUMB2
	STA	NUMB2
	LDA	NUMB3
	ADC	NUMB3
	STA	NUMB3
	DEY
	BPL	10$
	LDY	NUMB3
	LDX	NUMB2
	LDA	NUMB1
	CLD			;CLEAR DECIMAL FLAG
	RTS
;
;ALPHANUMERIC STRING DISPLAY
;ENTRY	- POINTR = ALPHA STRING (.ASCVG)
;	  RAMPTR = ADDR. IN VGRAM FOR LOADING CHAR JSRL'S
;ASSUMES CHARACTER SIZE IS DEFAULT
;ALL CHARACTERS IN STRING ARE DISPLAYED ( ,1-9,A-Z)
;# OF CHARACTER <- 127.
;EXIT	- RAMPTR = ADDR. NEXT BYTE IN VGRAM
DSPLAA:	STX	POINTR+1	;ASCVG SOURCE POINTER
	STY	POINTR
DSPLAY:	LDA	I,0		;RAMPTR INDEX
10$:	LSR
	TAY
	LDA	NY,POINTR
	STA	TEMP3		;ASCVG REP.
	AND	I,7F
	TAX
	TYA
	ASL
	TAY
	LDA	AX,VGMSGA		;INSERT CHAR. JSRL INTO
	STA	NY,RAMPTR		;VGRAM
	INY
	LDA	AX,VGMSGA+1
	STA	NY,RAMPTR
	INY
	TYA
	BIT	TEMP3
	BPL	10$			;DO NEXT CHARACTER
	CLC			;EXIT W/RAMPTR = NEXT BYTE IN VG RAM LIST
	ADC	RAMPTR
	STA	RAMPTR
	BCC	50$
	INC	RAMPTR+1
50$:	TYA
	LSR				;CARRY IS CLEARED
	ADC	POINTR			;SET POINTR TO NEXT BYTE
	STA	POINTR
	BCC	60$
	INC	POINTR+1		;ADD IN CARRY
60$:	RTS
;
;	MESSAGE TAKES MESSAGE # (IN ACC) AND PUTS IN VG RAM
;	X = LABS # (OFFSET IN MSSGLBS)
;
;	LABS (BY X) AND WAIT INSERTED IN VG RAM FOLLOWED
;	BY MESSAGE STRING (OFFSET IN ACC)
;
;	ALL REGS USED; LODRM4, SCRLD2, & DSPLAA ROUTINES CALLED
;
MESSFU:	LDA	I,23.		;FUEL UNITS
	JSR	MESSRG
	LDA	I,3.		;LOST 
	BNE 	MESSRG		;ALWAYS
MESSLAB:LDA	I,80		;NO MESSAGE
;
MESSAGE:PHA			;SAVE MESSAGE #
	TXA
	CLC
	ADC	I,MSSGLBS&0FF
	TAY
	LDA	I,MSSGLBS/100
	ADC	I,0
	LDX	RAMPTR		;SAVE POINTER
	STX	LABPTR		;IN CASE OF CRASH
	LDX	RAMPTR+1	;MESSAGES
	STX	LABPTR+1
	JSR	LODRM4		;LOAD LABS (4 BYTES)
	JSR	SCRLD2		;LOAD WAIT (4 BYTES)
	PLA			;ACC = MESSAGE #
	BMI	MESSEXT		;BRANCH - NO STRING TO DISPLAY
MESSRG:	PHA			;SAVE MESSAGE #
	LDX	LANG
	BEQ 	1$		;BRANCH - ENGLISH
	STA	TEMP2		;SAVE MESSAGE OFFSET
	DEX			;LANG-1 (0 1 2)
	LDA	AX,F.MIDX	;GET INDEX
	CLC
	ADC	TEMP2		;ADD MESSAGE #
	TAX
	LDA	AX,F.MOFF	;GET X POSITION OFFSET
	LDX	I,0		;ASSUME +
	ASL			;SHIFT OFFSET
	BCC	2$
	DEX			;EXTEND SIGN
	BCS	2$		;ADD IN OFFSET (ALWAYS)
1$:	SEC
	SBC	I,9		;CHECK FOR CRASH MESSAGES
	CMP	I,12.
	BCS	4$		;NOT A CRASH MESSAGE
	TAX			;X=TABLE OFFSET
	LDA	AX,E.MOFF	;GET X POSITION OFFSET
	LDX	I,0		;CLR SIGN BYTE
2$:	CLC
	LDY	I,2		;THIRD BYTE IS X POSITION
	ADC	NY,LABPTR	;LOWER X POSITION BYTE
	STA	NY,LABPTR
	TXA
	INY
	ADC	NY,LABPTR	;ADD IN CARRY TO TOP BYTE
	STA	NY,LABPTR
4$:	PLA			;RETRIVEVE MESSAGE #
	ASL			;ACC = MESSAGE # * 2
	CMP	I,24.*2
	BCS	10$		;ONLY ENGLISH
	LDX	LANG		;X = LANGUAGE #
	BEQ	10$		;BRANCH - ENGLISH
	DEX			;X = LANG # -1 (0 1 2)
	CLC
	ADC	AX,FTBLNG	;ADD FOREIGN LANG TABLE OFFSET
	TAX
	LDY	AX,FORMSG	;GET FOREIGN MESSAGE POINTER
	LDA	AX,FORMSG+1
5$:	TAX
	JMP	DSPLAA		;DISPLAY MESSAGE [X,Y = POINTER]
10$:	TAX
	LDY	AX,ENGMSG	;GET ENGLISH MESSAGE POINTER
	LDA	AX,ENGMSG+1
	BNE	5$		;ALWAYS
MESSEXT:RTS
;
	.PAGE
	.SBTTL	NMI
;
;	INTERRUPT OCCURS EVERY 4 MS. [FROM HARDWARE]
;
NMI:	PHA			;SAVE REGISTERS
	TXA
	PHA
	TYA
	PHA
	CLD
;
;POT CONVERSION ROUTINE
;
	LDA	A,POTIN		;GET POT READING
	SEC			;A = POT READING
	SBC	POTMIN		;CHK MIN
	BCS	10$		;BRANCH > MIN
	DEC	POTMIN		;LOWER MIN
	LDA	I,0
10$:	CMP	PTRNGE		;CHK RANGE
	BCC	20$		;BRANCH - WITHIN
	INC	PTRNGE		;INCREASE RANGE
	LDA	PTRNGE
20$:	TAX
	SEC
	SBC	POTVAL
	BCC	40$		;CHECK -3 IF BORROW
	LSR			;ELSE CHECK +3
	LSR
	BEQ	NMTIME		;NO CHANGE
30$:	STX	POTVAL		;UPDATE POT VALUE
	INC	POTUSE
	BNE	NMTIME		;ALWAYS
40$:	ADC	I,3		;CARRY IS CLR
	BMI	30$		;BEYOND NOISE
NMTIME:
	INC	INTCNT		;INCREMENT INT (4 MS) COUNTER
	LDA	INTFLG		;CHK FRAME(S)
	CMP	I,3
	BCS	1$		;60 MS W/O FRAME
	STA	A,WATCH		;CLR WATCHDOG
	LDA	SOFT.0		;CHK RAM 'WATCH' LOCATIONS
	EOR	SOFT.1
	EOR	SOFT.1+1
	CMP	I,SOFTWD
	BEQ	2$		;BRANCH IF OK
1$:	JMP	1$		;WAIT FOR WATCHDOG TO RESTART
2$:	JSR	MOOLAH		;COIN ROUTINE
	BCC	3$
	LDX	I,CNCNTR	;SET COIN COUNTER
	LDA	I,0FF
	BNE	5$		;ALWAYS BRANCH
3$:	LDA	I,NCNCNTR
	LDX	I,0
5$:	JSR	L.LED		;SET COIN COUNTER AS APPROPRIATE
	BIT	GAMODE
	BVC	14$		;BRANCH - NOT PLAY
	DEC	TIMVAL		;COUNT TIME IN PLAY MODE
	BNE	14$
	LDA	I,SECCNT
	STA	TIMVAL
	INC	TIMER		;COUNT GAME SECONDS
	SED
	LDA	FLMIN		;FLFACT * GAME TIME
	CLC
	ADC	I,FLFACT
	STA	FLMIN
	LDA	FLMIN+1
	ADC	I,0
	STA	FLMIN+1
	LDA	FLMIN+2
	ADC	I,0
	STA	FLMIN+2
11$:	LDA	GMTIME		;GAME PLAY TIME
	CLC
	ADC	I,1
	CMP	I,60
	BCC	12$
	LDA	I,0
12$:	STA	GMTIME
	LDA	GMTIME+1
	ADC	I,0		;ADD 1 (IF CARRY SET)
	STA	GMTIME+1
14$:	CLD			;CLEAR DECIMAL MODE
15$:	LDA	GAMODE		;MODULATE GAME TYPE LAMPS
	BNE	20$		;IN ATTRACT
	LDA	INTCNT		;50 % DUTY CYCLE
	LDX	I,1F		;ASSUME SET ON
	LSR
	BCC	16$		;SET ON
	LDX	I,10		;ELSE - TURN OFF
16$:	LDA	I,0
	JSR	L.LED		;SET LEDS
20$:	DEC	VGCOUNT		;CHK FOR EOF [END OF FRAME]
	BNE	NMEXIT
	LDA	I,FRMECNT
	STA	VGCOUNT		;RESET FRAME COUNT
	INC	INTFLG		;FRAME SYNC [EVERY 24MS]
NMEXIT:	PLA			;RESTORE REGISTERS
	TAY
	PLA
	TAX
	PLA
	RTI
	.PAGE
	.SBTTL	DISPLAY DIGITS
;
;DIGITS - DISPLAY 2Y DIGIT NUMBERS
;
;ENTRY	(C) = CARRY SET FOR ZERO SUPPRESSION
;	(A) = ADDRESS OF (Y) ZERO PAGE LOCATIONS CONTAINING NUMBER (LSB TO MSB)
;	(Y) = NUMBER OF ZERO PAGE LOCATIONS TO USE (1 TO 256).
DIGT2S:	LDY	I,2
DIGTYS:	SEC
DIGITS:	PHP			;SAVE INPUT PARAMETERS
	DEY
	STY	TEMP1+1
	CLC
	ADC	TEMP1+1
	PLP
	TAX			;MSB OF DIGITS
10$:	PHP
	STX	TEMP1		;SAVE DIGIT ZP OFFSET
	LDA	ZX,0
	LSR
	LSR
	LSR
	LSR
	PLP
	JSR	VGHEXZ		;FIRST DIGIT
	LDA	TEMP1+1
	BNE	20$
	CLC			;DISPLAY LAST DIGIT (EVEN 0)
20$:	LDX	TEMP1
	LDA	ZX,0
	JSR	VGHEXZ		;SECOND DIGIT
	LDX	TEMP1
	DEX
	DEC	TEMP1+1
	BPL	10$		;LOOP FOR EACH SET OF DIGITS
	RTS
	.PAGE
	.SBTTL	POWER ON & SELF TEST ROUTINES
;
;
;
PWRON:	LDX	I,INITSTK
	TXS			;INITIALIZE STACK
STEST:				;ENABLE INTERRUPTS
	CLD			;CLEAR DECIMAL MODE
	LDA	I,0
	STA	A,NOISE		;CLC NOISE
	TAX
10$:	STA	ZX,0		;CLEAR ZERO PAGE
	INX
	BNE	10$
	LDA	A,TESTSW	;BIT 1=SELF TEST
	LSR
	LSR
	BCS	PWRINT		;CONTINUE POWER ON
	JMP	RAMTST		;CONTINUE SELF TEST
PWRINT:	LDA	I,SOFTWD	;INITIALIZE SOFTWARE WATCHDOG BYTES TO OBSCURE VALUE
	STA	SOFT.0
	STA	SOFT.1
	STA	SOFT.1+1
	LDA	I,0FF
	STA	POTMIN		;INITIALIZE POT. MIN.=0FF
	LDA	I,FRMECNT
	STA	VGCOUNT		;FRAME=24.MS (4 MS. * 6)
	LDA	I,2
	STA	ARRWX		;INITIALLY NO VELOCITY ARROWS
	STA	ARRWY
	STA	A,WATCH		
	JMP	START		;GO TO ATTRACT
;
;
;
	.SBTTL	ZERO-PAGE TEST
RAMTST:	LDX	I,11		;BEGINNING PATTERN
	TXS			;S HOLDS PATTERN
	TXA
	STA	Z,0		;TEST CELL START @ 0
	LDY	I,0
2$:	LDX	I,1		;ONE LESS COUNT BEFORE IT WRAPS
3$:	INY			;SCAN FORWARD
	LDA	AY,0		;ZERO ?
	BNE	6$		;NO - ERROR (HIGH BITS BAD)
	INX			;CHK HOW FAR SCANNED
	BNE	3$		;BRANCH - CONTINUE
	TSX
	TXA			;ACC = PATTERN
	STA	A,WATCH		;WATCHDOG
	INY			;POINT TO TEST CELL
	CMP	AY,0		;DOES IT HAVE PATTERN ?
	BNE	5$		;N0 - BRANCH (ERROR) (NOT (PATTERN) BITS BAD)
	LDX	I,0
	STX	ZY,0		;ELSE - CLEAR CELL
	INY			;POINT TO NEXT TEST CELL
	BNE	4$		;IF PASS NOT COMPLETE
	ASL			;ELSE SHIFT PATTERN
	LDX	I,0
	BCS	7$		;BRANCH - DONE (GOOD)
4$:	TAX			;PATTERN -> X
	TXS			;	 -> S
	STX	ZY,0		;	 -> NEXT TEST CELL
	BNE	2$		;ALWAYS - REPEAT SCAN
5$:	EOR	AY,0		;HIGH BITS ARE BAD
6$:	TAX			;ANY HIGH BITS INDICATE BAD RAM
7$:	TXA
	LDY	I,10		;ASSUME LOW NIBBLE IS GOOD
	AND	I,0F		;CHECK IT
	BEQ	8$		;BRANCH - LOW NIBBLE GOOD
	LDY	I,20		;ELSE - SET Y ACCORDINGLY
8$:	TXA
	LDX	I,10		;ASSUME TOP NIBBLE IS GOOD
	AND	I,0F0		;CHECK IT
	BEQ	9$		;BRANCH - TOP NIBBLE GOOD
	LDX	I,20		;ELSE - SET X
9$:
	TYA
	TXS
	TAX
RT.LP:	STX	A,NOISE		;NOISE = LOWER NIBBLE STATUS
	LDY	I,12.		;Y = HIGH BYTE OF COUNTER
10$:	LDX	I,100.		;X = LOW BYTE OF COUNTER
11$:	BIT	A,TESTSW
	BVS	11$		;BIT 6 (V FLAG) OF TESTSW = 3000 HZ SQUARE WAVE
12$:	BIT	A,TESTSW
	BVC	12$
	STA	A,WATCH
	DEX
	BNE	11$		;INNER LOOP 255. * 333 US = 85 MS
	CPY	I,5
	BNE	13$
	STX	A,NOISE		;CLR NOISE
13$:	DEY
	BNE	10$		;OUTER LOOP 8 *  85 MS = 580 MS
	TAY			;TEST SIGN
	BMI	14$		;DONE
	ORA	I,80		;SET SIGN
	TSX
	BPL	RT.LP		;ALWAYS
14$:	CMP 	I,90		;ACC=^90?
	BNE	17$		;NO-BAD RAM
	TSX
	CPX	I,10		;X=^10?
	BEQ	18$		;YES- ZP RAM GOOD
17$:	STA	A,WATCH		;WATCHDOG
	JMP	17$		;LOCKUP - BAD ZP RAM
18$:	LDX	I,INITSTK
	TXS			;INITIALIZE STACK (USED IN ROM TESTS)
;
;	CLEAR VG RAM
;
VRAMCLR:JSR	D.RMPT		;0 TO BE STORED IN VG RAM CELLS
	TAY
				;Y = 0
10$:	STA	NY,RAMPTR	;CLR RAM
	INY
	BNE	10$		;CONTINUE FOR ENTIRE PAGE
	INC	RAMPTR+1	;INCREMENT FOR NEXT PAGE
	LDX	RAMPTR+1
	CPX	I,VGRAM/100+8	;CKH IF DONE - 8 PAGES OF VG RAM
	BCC	10$		;BRANCH - DO NEXT PAGE (Y=0, ACC=0)
;
;	VECTOR GEN RAM TEST
;
	.SBTTL	VG RAM TEST
VRAMTST:JSR	D.RMPT		;TEST CELL START @ VGRAM
1$:	LDA	I,11		;BEGINNING PATTERN
	STA	TEMP1		;TEMP1 HOLDS PATTERN
				;Y=0
	STY	TSFLAG		;CLEAR FLAG
	STA	NY,RAMPTR	;TEST CELL START
				;Y=0
2$:	TYA
	TAX			;X = TEST CELL OFFSET
3$:	INY			;SCAN FORWARD
	BEQ	4$		;BRANCH - FINISHED WITH PAGE
	LDA	NY,RAMPTR	;ZERO ?
	BNE	9$		;NO - ERROR
	BEQ	3$		;ALWAYS
4$:	TXA
	TAY			;Y POINTS TO TEST CELL
	LDA	TEMP1		;ACC = PATTERN
	STA	A,WATCH		;WATCHDOG
	CMP	NY,RAMPTR	;DOES IT HAVE PATTERN ?
	BNE	8$		;IF NOT - ERROR
	LDA	I,0
	STA	NY,RAMPTR	;CLEAR CELL
	LDA	TEMP1		;LOAD PATTERN
	INY			;POINT TO NEXT TEST CELL
	BNE	6$		;BRANCH - IF PASS NOT COMPLETE
	ASL			;ELSE SHIFT PATTERN
	BCS	7$		;BRANCH - IF DONE W/PAGE
6$:	STA	TEMP1		;SAVE PATTERN
	STA	NY,RAMPTR	;NEW TEST CELL
	BNE	2$		;ALWAYS - REPEAT SCAN
7$:	INC	RAMPTR+1	;POINT TO NEXT PAGE
	LDA	RAMPTR+1
	CMP	I,VGRAM/100+8	;CHECK FOR SCAN END (8 PAGES OF VG RAM)
	BCC	1$		;BRANCH - SCAN NEXT PAGE
	BCS	13$		;DONE - VGRAM OK
				;ERROR IN VG RAM
8$:	EOR	NY,RAMPTR	;SET BAD BITS HIGH
9$:	LDX	I,0		;HIGH BITS ARE BAD
	PHA
	AND	I,0F0		;CHK TOP BYTE
	BEQ	10$
	LDX	I,2		;X(BIT 1) = 1 IF TOP NIBBLE BAD
10$:	PLA
	AND	I,0F
	BEQ	11$
	INX			;X (BIT 0) = 1 IF LOW NIBBLE BAD
11$:	TXA
	LDX	RAMPTR+1
	CPX	I,VGRAM/100+4	;CHECK WHICH RAM
	BCC	12$		;LEAST RAM(S) [4000-43FF]
	ASL			;HIGH RAM(S) [4400-47FF]
	ASL
12$:	ORA	TSFLAG		;HIGH BITS INDICATE BAD RAMS
	STA	TSFLAG
13$:	LDA	TSFLAG
	STA	A,LEDS
	LDA	I,3
	STA	INDEX		;RAM COUNTER
	CLC			;CARRY CLEAR FOR FIRST SHIFT
14$:	LDA	I,10		;ASSUME GOOD RAM
	ROR	TSFLAG
	PHP			;SAVE CARRY
	BCC	15$
	ASL			;BAD RAM (ACC = 20)
15$:	STA	A,NOISE
	LDY	I,80.
	JSR	D.DELY		;80 COUNTS WITH NOISE= 533 MS
	STX	A,NOISE		;CLR NOISE
	LDY	I,40.
	JSR	D.DELY		;40 COUNTS SILENT= 267 MS
	PLP
	DEC	INDEX
	BPL	14$
	ROR	TSFLAG		;BITS D7 TO D4 = RAM STATUS
20$:	STA	A,WATCH		;WATCHDOG
	BNE	20$		;LOCKUP - BAD VG RAM
;
;	ROM TEST
;
ROMTST:				;PROG STARTS ON EVEN PAGE
	LDA	I,VGROM/100	;HIGH ROM ADDRESS BYTE
	STA	POINTR+1	;HIGH ADDRESS POINTER
	JSR	D.RMPT
	STA	POINTR		;LOW ADDRESS POINTER
	STA	TSFLAG		;CLR ROM FLAG (0 = OK)
	STA	TEST		;CLR FLAG
	JSR	BMNBLK		;TO STOP BEAM BLANKING CKT
	LDA	I,18.		;TABLE OFFSET FOR ROM MESSAGE LABS
	JSR	RMCHAR		;PUT LABS & WAIT INTO VG RAM
	LDX	I,55.		;56 PAGES OF ROM
	TXA			;SEED FOR L.R.C.
	ASL			;GET SOMETHING IN EACH NIBBLE (6E)
10$:	LDY	I,0
	STA	A,WATCH		;WATCHDOG
11$:	EOR	NY,POINTR	;LONGITUDINAL PARITY
	INY
	BNE	11$		;LOOP FOR 1 PAGE
	TAY			;SAVE LRC
	TXA
	AND	I,3		;2 LSB = 1K ROM
	CMP	I,1		;CLEAR CARRY IF END OF ROM
	TYA			;ACC = LRC
	BCS	23$		;BRANCH - STILL IN ROM
	BEQ	22$		;BRANCH - ROM OK (LRC = 0)
	STA	TSFLAG		;ELSE - SET FLAG (BAD ROM)
				;DISPLAY (ROM # IN X (*4))
				;BAD NIBBLE(S) IN ACC
	STX	TEMP3		;TEMP1 = ROM # (*4)
	LDA	I,52.
	SEC
	SBC	TEMP3
	LSR
	STA	TEMP3+1		;TEMP3+1 = ROM # (* 2)
	SEC
	SBC	I,MINTST	;CHECK FOR ALPHANUMERIC (VG) ROMS
	CMP	I,4		;ARE THEY GOOD ?
	BCS	12$		;YES (BRANCH)
	DEC	TEST		;ELSE MINUS TEMP6 (BIT 7 SET)
12$:	LDA	TSFLAG		;TSFLAG = NIBBLES OF LRC
	AND	I,0F		;CHECK BOTTOM NIBBLE
	BEQ	19$		;BOTTOM NIBBLE OK
	JSR	R.NUMB		;DISPLAY ROM # (LEAST)
19$:	LDA	TSFLAG
	AND	I,0F0		;CHECK TOP NIBBLE
	BEQ	20$		;TOP NIBBLE OK
	INC	TEMP3+1
	JSR	R.NUMB		;DISPLAY ROM # (MOST)
20$:	LDX	TEMP3		;X = PAGE COUNTER
22$:	TXA			;RE-SEED FOR NEW ROM
23$:	INC	POINTR+1	;BUMP POINTR (NEXT PAGE)
	DEX			;COUNT PAGES
	BPL	10$
	LDX	TSFLAG
				;CHK ROM STATUS HERE
				;ROM OK IF X=0
	BEQ	24$		;BAD ROM
	BIT	TEST		;CHK ALPHANUM ROM STATUS
	BPL	25$		;BRANCH - OK
	LDA	I,VGRAM+18/100
	STA	RAMPTR		;RESET POINTER
	LDA	I,VGRAM+18&0FF
	STA	RAMPTR
	LDA	I,34.		;LOAD DISPLAY FOR BAD
	LDX	I,14.		;ALPHANUM ROM
	JSR	ROMDSP		;LOAD VG RAM
	JMP	25$
24$:	LDX	A,PROMOK+1	;DISPLAY 'ROM OK'
	LDY	A,PROMOK
	JSR	DSPLAA
25$:	LDA	I,0
	STA	INDEX		;CLR LAMP COUNTER
	STA	TEMP3		;CLR STATE COUNTER
	STA	NOISZP		;CLR NOISE ZP STATUS
	LDA	I,11
	STA	A,LEDS		;INITIALIZE LAMP 0 ON
	LDA	RAMPTR+1		;INITIALIZE VG RAM POINTER
	STA 	PTRTMP+1
	LDA	RAMPTR
	STA	PTRTMP
				;CONTINUE TO D.SWTH
;
;
D.SWTH:	LDX	I,7
10$:	LDA	AX,STARTSW		;D7=SWITCH BIT
	ASL				;CARRY=SWITCH BIT
	ROL	SWITCH			;ROLL BIT INTO SWITCH
	DEX
	BPL	10$			;CONTINUE FOR ALL 8 SWITCHES
	LDA	A,TESTSW		;CHECK SLAM SWITCH
	AND	I,4			;BIT 4 = SLAM SWITCH (0 = TRUE)
	STA	SWITCH+1
	LDX	I,0			;ASSUME NO CHANGE
	LDA	OLDSW			;CHECK OLD SWITCH STATE
	EOR	SWITCH			;W/NEW
	BNE	15$
	LDA	OLDSW+1
	EOR	SWITCH+1
	BEQ	20$			;BRANCH - NO CHANGE
15$:	LDX	I,30			;ELSE - SET TONES
20$:	LDA	I,0F		;AND MASK
	JSR	S.SND		;SET TONES ACCORDINGLY
	LDA	SWITCH
	STA	OLDSW
	LDA	SWITCH+1
	STA	OLDSW+1
	LDA	PTRTMP
	STA	RAMPTR
	LDA	PTRTMP+1
	STA	RAMPTR+1
	BIT	TEST		;CHECK FOR BAD ALPHANUMERIC ROM
	BMI	22$		;BRANCH - ROM IS BAD
	LDA	I,26.			;LOAD LABS & WAIT
	JSR	RMCHAR		;LOAD LABS & WAIT (ACC IS OFFSET)
	LDY	I,1
	LDA	A,POTIN			;READ VALUE
	CLC
	ADC	POTVAL			;AVERAGE 2 READING
	ROR
	STA	POTVAL			;AND STORE IT
	LDA	I,POTVAL
	JSR	DIGTYS			;DISPLAY VALUE
	JSR	DSPATTR		;DISPLAY MECH OPTION IN PROPER LANG.
	LDA	I,3A
	JSR	RMCHAR		;LABS & WAIT
	JSR	C.MEC2		;GET MECH 2 OPTION
	LDA	I,M2.OPT	;DISPLAY MECH #2 OPTION (FACTOR)
	LDY	I,1
	JSR	DIGTYS
22$:	JSR	D.FEND		;PUT HALT IN VG RAM & DELAY FOR FRAME
	INC	INDEX			;COUNT FRAMES
	LDA	INDEX
	CMP	I,20		;CHECK FOR 32 FRAMES
	BCC	30$		;@ 32 FRAMES (.625 SECONDS)
	LDX	TEMP3+1		;GO TO NEXT LAMP STATE
	INX
	CPX	I,5			;5 LAMP STATES
	BCC	25$
	LDX	I,0			;GO TO STATE 0
25$:	STX	TEMP3+1		;SET STATE
	LDA	AX,S.LTAB		;GET LED OUTPUT STATE
	STA	A,LEDS
	LDA	AX,S.STAB	;GET SOUND STATE
	TAX
	LDA	I,30		;ACC = AND MASK
	JSR	S.SND		;SET SOUNDS
	STY	INDEX		;CLR INDEX (Y = 0)
30$:	JSR 	D.NEXT			;FRAME
	BCS	D.TEST
	JMP	D.SWTH			;CONTINUE UNTIL DIAG STEP
;
;D.TEST LOADS DIAGNOSTICS IN VG RAM AND STEPS THROUGH PER
;DIAG TEST SW (DEBOUNCED IN D.TEST)
;TESTS ARE:	DIAG1	DIAGONAL LINE
;		DIAG2	DIAGONAL CROSS-HATCH
;		DIAG3	JSRL TEST (SUBROUTINES)
;		DIAG4	SHADED HORIZ LINES
;
D.TEST:	LDX	I,0
	STX	A,NOISE		;CLR SOUNDS
D.DIAG:	STX	TEST		;INITIALLY DIAG1 TEST
	JSR	D.RMPT
	LDY	TEST		;TEST=DIAG TEST # (0 TO 3)
	CPY	I,LASTST	;CHECK FOR SHADED LINES
	BNE	5$		;NO
				;ELSE CONSTRUCT INTENSITY LINES
	LDA	I,30
	JSR	RMCHAR		;LOAD LABS & WAIT
	LDA	I,0FB		;INITIAL VCTR (BYTE 1 OF ALPH)
1$:
	LDY	I,0
	STA	NY,RAMPTR	;BYTE 0
	INC	RAMPTR
	PHA
	LDA	I,0F8		;BYTE 1
	STA	NY,RAMPTR
	INC	RAMPTR		;LIST IS LESS THAN 256.
	LDA	I,38
	LDX	I,2
	JSR	ROMDSP		;OFFSET VCTR (ALPH)
	PLA
	SEC
	SBC	I,10		;NEXT LOWER INTENSITY
	BCS	1$		;CONTINUE
	BCC	7$		;ALWAYS
5$:	LDX	AY,DTBLOFF	;GET # OF BYTES IN TEST
	TYA
	ASL
	TAY			;OFFSET FOR DIAGTBL (TEST POINTER)
	LDA	AY,DIAGTBL+1	;TOP BYTE
	PHA			;SAVE IT
	LDA	AY,DIAGTBL	;LOWER BYTE
	TAY
	PLA			;ACC,Y=ADDR OF TEST LIST
				;X=# OF BYTES
	JSR	LOADRAM		;LOAD VG RAM
7$:	JSR	D.FEND
;
10$:	JSR	D.FRME		;DELAY FRAME TME (= 20 MS)
	JSR	D.NEXT		;DEBOUNCE DIAG STEP SWITCH
	BCC	10$
	LDX	TEST
	INX
	CPX	I,LASTST+1	;CHK FOR LAST TEST
	BCC	D.DIAG		;EXECUTE NEXT TEST
	JMP	PWRINT		;END OF TESTS
;
;INITIALIZE RAMPTR
;
D.RMPT:	LDA 	I,VGRAM/100
	STA	RAMPTR+1
	LDA	I,VGRAM&0FF
	STA	RAMPTR
	RTS
;
;	LOAD BYTES INTO VG RAM FOR ROM STATUS DISPLAY
;		RAMPTR = POINTER INTO VG RAM
;		PVGTST = TABLE OF DISPLAY CHARACTERS ,LABS, & VCTRS
;	ENTER - X=# OF BYTES TO MOVE
;		A=OFFSET INTO PVGTEST
;	EXIT - RAMPTR = NEXT FREE BYTE
;	       ALL REGS BLITZED
;
RMCHAR:	LDX	I,8			;8 BYTES
ROMDSP:	CLC
	ADC	A,PVGTST
	TAY
	LDA	A,PVGTST+1
	ADC	I,0
	JMP	LOADRAM
;
;
;
D.FEND:	LDA	I,FINI/100		;BEAM REST LABS & HALT
	LDY	I,FINI&0FF
	LDX	I,6
	JSR	LOADRAM
D.FRME:	STA	A,VGON			;STROBE VG
					;DELAY = 20 MS (FRAME LENGTH)
	LDY	I,3			;Y=HIGH BYTE COUNTER
D.DELY:	STA	A,WATCH		;WATCHDOG
	LDX	I,20.			;X=LOW BYTE COUNTER
20$:	BIT	A,TESTSW
	BVS	20$
30$:	BIT	A,TESTSW
	BVC	30$
	DEX
	BNE	20$			;INNER LOOP: 200.*333US=6.67M
	DEY
	BNE	D.DELY			;OUTER LOOP: Y*6.67MS=
					;(FROM D.FRME = 20MS)
	RTS
;
;DEBOUNCE DIAG STEP SWITCH
;
D.NEXT:	BIT	A,TESTSW	;BIT 7=DIAG STEP SWITCH (LOW TRUE)
	BMI	20$		;NOT PUSHED
	ASL	D.SCNT		;SHIFT BIT TO LEFT
10$:	RTS			;CARRY SET ON DEBOUNCE
20$:	LDA	I,20
	STA	D.SCNT		;INITIALIZE DEBOUNCE COUNTER
	CLC
	BCC	10$		;ALWAYS (CARRY CLEAR=NO DEBOUNCE)
;
;
;LOADRAM MOVES BYTE FROM (RAMLD) TO
;(RAMPTR), X=# OF BYTES, Y,A = (LO),(HI) ADDR. TO LOAD FROM, AT EXIT
;RAMLD & RAMPTR POINT @ NEXT BYTE
;
LODRM8:	LDX	I,8		;STANDARD = 8 BYTES
LOADRAM:STA	RAMLD+1		;A,Y=HI,LO ADDR. OF SOURCE
	STY	RAMLD
LDRAM:	TXA			;ASSUMES RAMLD, RAMPTR ARE CORRECT
	TAY
	DEY
10$:	LDA	NY,RAMLD	;MOVE BYTES FROM RAMLD TO RAMPTR
	STA	NY,RAMPTR	;# OF BYTES =[X]
	DEY
	BPL	10$
	TXA
	CLC
	ADC	RAMPTR		;UPDATE RAMPTR
	STA	RAMPTR
	BCC	20$
	INC	RAMPTR+1
20$:	TXA
	CLC
	ADC	RAMLD		;UPDATE RAMLD
	STA	RAMLD
	BCC	30$
	INC	RAMLD+1
30$:	RTS			;EXIT RAMPTR=NEXT FREE BYTE
				;RAMLD = NEXT AVAILABLE BYTE
;
LODRM2:	LDX	I,2		;MOVE 2 BYTES RAMLD >> RAMPTR
	BNE	LOADRAM		;ALWAYS BRANCH
;
LODRM4:	LDX	I,4		;MOVE 4 BYTES
	BNE	LOADRAM		;ALWAYS BRANCH
;
LDRAM4:	LDX	I,4		;MOVE 4 BYTES (W/EXISTING POINTERS)
	BNE	LDRAM		;ALWAYS
;
SCRLDO:	CLC
	ADC	OFFSET		;ADD TABLE OFFSET TO POINTER (ACC & X)
	TAY
	TXA
	ADC	I,0
SCRLOAD:LDX	I,0		;CLEAR ROTATE VALUE
	STX	DELX
	LDX	I,0F
	STX	DELX+1		;CLEAR QUADRANT VALUE
SCRLD1:	STA	RAMLD+1		;RAMLD = SOURCE POINTER
	STY	RAMLD
	LDY	I,0
	LDA	NY,RAMLD
	SEC
	SBC	SCRADD+1	;DO Y AXIS SCROLLING
	STA	NY,RAMPTR
	INY
	LDA	NY,RAMLD
	SBC	SCRADD+2
	AND	I,0F
	ORA	I,0A0
	STA	NY,RAMPTR	;Y AXIS
	INY
	LDA	NY,RAMLD
	SEC
	SBC	SCROLL+1	;X AXIS SCROLLING
	STA	NY,RAMPTR
	INY
	LDA	NY,RAMLD
	SBC	DELX		;SUBTRACT ROTATE FACTOR
	AND	DELX+1		;SET QUADRANT
	STA	NY,RAMPTR
	JSR	VGADD		;UPDATE RAMPTR
SCRLD2:	LDA	I,WAIT7/100
	LDY	I,WAIT7&0FF
	JMP	LODRM4		;ADD IN LABS WAIT [AND RETURN]
;
;
;
R.NUMB:	LDX	I,0
	LDY	TEMP3+1		;CONVERT ROM # (TEMP3+1) INTO DECIMAL
	JSR	DECIMAL
				;NUMB1=ROM # (DECIMAL)
	LDA	I,NUMB1
	SEC			;NO LEADING ZEROS
	LDY	I,1		;DISPLAY 2 DIGITS
	JSR	DIGITS
	LDA	I,16.
	LDX	I,2
	JMP	ROMDSP		;PUT BLANK INTO VG RAM
;
;
;
BMNBLK:	LDA	I,0		;LABS FOR CORRECTING HARDWARE
				;BEAM BLANKING BUG
	LDX	I,10		;22. BYTES DOWN THE DRAIN
	JMP	ROMDSP		;LOAD TWO LABS & WAITS
;
R.LAB:	LABS	0,0		;2 LABS GIVES HARDWARE THE
	WAIT	9		;IMPRESSION THAT THE BEAM IS MOVING
	LABS	1023.,767.	;BEYOND THE MINIMUM THRESHOLD
	WAIT	9
;
R.BLNK:	VCTR	24.,0,0		;BLANK SPACE
;
VGTLBS:	LABS	16.,600.		;LABS
	WAIT	7			;& WAIT
;
D.VGPT:	LABS	512.,384.		;BEAM POSITION
	WAIT	7			;BEAM WAIT
;
;
R.ALPH:	VCTR	48.,0,12.	;SQUARE (W/X)
	VCTR	0,-48.,12.
	VCTR	-48.,0,12.
	VCTR	0,48.,12.
	VCTR	48.,-48.,12.
	VCTR	-48.,0,0
	VCTR	48.,48.,12.
;
DIAG4:	LABS	512.,400.
	WAIT	9
;
	VCTR	-48.,-16.,0
;
	LABS	374.,500.
	WAIT	7
;
ROMOK:	.ASCVG	<ROM OK>
;
PVGTST:	.WORD	R.LAB
PROMOK:	.WORD	ROMOK
;
S.LTAB:	.BYTE	11,12,14,18,0		;LAMP STATES
;
S.STAB:	.BYTE	1,3,7,0F,0		;SOUND STATES
	.PAGE
	.RADIX	10
	.SBTTL	VG DIAG TEST ROUTINES
;
.DIAG	=12
;
DIAG1:	LABS	512,384		;DIAGONAL LINE
	WAIT	9
	VCTR	200,200,.DIAG
	JMPL	14		;JUMP TO 14.
;
DIAG2:	LABS	0,0		;DIAGONAL CROSS HATCH
	WAIT	9
	VCTR	767,767,.DIAG
	VCTR	255,-255,.DIAG
	VCTR	-511,-511,.DIAG
	VCTR	-511,511,.DIAG
	VCTR	255,255,.DIAG
	VCTR	767,-767,.DIAG
	VCTR	1,767,0		;@ 1023,767
	VCTR	-767,-767,.DIAG
	VCTR	-255,255,.DIAG
	VCTR	511,511,.DIAG
	VCTR	511,-511,.DIAG
	VCTR	-255,-255,.DIAG
	VCTR	-767,767,.DIAG
;
DIAG3:	LABS	512,384
	WAIT	9
	JSRL	1$-DIAG3	;NESTED SUBROUTINES
	HALT			;HALT
1$:	JSRL	2$-DIAG3
	RTSL
2$:	JSRL	3$-DIAG3
	RTSL
3$:	VCTR	48,48,.DIAG
	VCTR	-48,48,.DIAG
	RTSL
;
DIAGTBL:.WORD	DIAG1
	.WORD	DIAG2
	.WORD	DIAG3
;
DTBLOFF:.BYTE	DIAG2-DIAG1,DIAG3-DIAG2,DIAGTBL-DIAG3
;
;INTERRUPT VECTORS
;
;
	.SBTTL	CHKSUM #13 (7C00 - 7FFF) [04]
	.VCTRS	^H7FF8,0	;CHKSUM
;
	.VCTRS	^H7FFA,NMI	;NMI VECTOR
	.VCTRS	^H7FFC,PWRON	;RESET VECTOR
	.VCTRS	^H7FFE,PWRON	;IRQ VECTOR
;
	.NLIST
	.REPT	100
	.WORD	0
	.ENDR
	.END
                                                                                                                                                                                                                                                                                                                                                                                 
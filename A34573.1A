	.TITLE	LUNAR - LUNAR LANDER
	.SBTTL	*********************************
	.SBTTL	*
	.SBTTL	* PROGRAMMER:  RICH MOORE
	.SBTTL	*
	.SBTTL	* CHECKER:	CHRIS DOWNEND, ED LOGG, & MIKE ALBAUGH
	.SBTTL	*
	.SBTTL	*********************************
;
;DATE INITIATED:	SEPT 10, 1978
;PROJECT CHARGE #:	169XX
;DISK #:		49 & B47
;HARDWARE REQUIREMENTS:	VECTOR GENERATOR HARDWARE
;
;MEMORY REQUIREMENTS:
;	VG RAM		- 4000-47FF HEX
;	VG ROM		- 4800-5FFF HEX
;	PROGRAM ROM	- 6000-7FFF HEX
;	ZERO PAGE	- 0000-00FF HEX
;	I/O		- 2400-2407 HEX
;			- 3200,3400 HEX
;			- 3C00,3E00 HEX
;
;INTERRUPT REQUIREMENTS:
;	NMI		- HARDWARE (4 MSEC)
;
;ASSEMBLY COMMAND STRING:
;	DX1:LUNAR,DK1:LUNAR=DX1:LUNAR
;
;LINK COMMAND STRING:
;	3M:/L,DK1:LULU.LST=DX1:LUNAR,DX1:LUNVCT,DX1:LUNCON,DX1:LUNINT
;
;PROGRAM DESCRIPTION:
;	1 PLAYER LUNAR LANDER VECTOR GENERATOR GAME
;
	.PAGE
	.INCLUDE ASCVG
;
	.TITLE	LUNAR - LUNAR LANDER
	.PAGE
	.ASECT
	.RADIX	16
	.SBTTL	CONSTANTS & VARIABLES
;
;CONSTANT DEFINITIONS
;
SOFTWD	=85			;SOFTWARE WATCHDOG BYTE VALUE
FUELFAC	=0DA			;FUEL USE FACTOR
FLFAC2	=90			;FUEL USE FACTOR (FOR GAME #2)
FLMFRC	=74			;FLAME FRACTION
ABTCNT	=100.			;ABORT COUNT
ABTMIN	=60.			;ABORT MIN COUNT (FOR MIN VELY CHECK)
M.HRDY	=10.			;HARD LANDING Y VELOCITY (BOUNCE)
M.HRDG	=65.			;HARD LANDING GRAVITY (BOUNCE)
BNFUEL	=50			;BONUS FUEL
FRMECNT	=6			;FRAME LENGTH (*4MS.) = 24. MS.
DEDCNT	=127.			;DEDUCT FUEL MESSAGE COUNT
FLFACT	=8			;8 FUEL/UNITS/SEC
SECCNT	=250.			;SECOND = 250. * NMI (4 MS.)
INITSTK	=0FF			;STACK INITIALIZED ADDR
TESTSW	=2000			;TEST SWITCH ADDR
				; D0 = SELF TEST
				; D1 = SPARE
				; D2 = SLAM (LOW TRUE)
				; D6 = 3 KHZ SQUARE WAVE
				; D7 = DIAG STEP
VGHLT	=2400			;VG HALT = BIT D7
VGON	=3000			;VEC GEN ON ADDR
VGCONT	=3800			;VG CONTINUE
VGRAM	=4000			;VEC GEN RAM STARTING ADDR
VGROM	=4800			;VEC GEN ROM STARTING ADDR
;
;NEW PC BOARD ADDRESSES
;
LEDS	=3200			;PLAYER LEDS
NOISE	=3C00			;NOISE (SOUNDS)
WATCH	=3400			;WATCHDOG
NSREST	=3E00			;NOISE RESET
STARTSW	=2400			;START SWITCH(D7 1=TRUE)
COIN3	=2401			;COIN MECH 3 (D7 1=TRUE)
COIN2	=2402			;COIN MECH 2 (D7 1=TRUE)
COIN1	=2403			;COIN MECH 1 (D7 1=TRUE)
TYPESW	=2404			;GAME SELECT (D7 1=TRUE)
ABORTSW	=2405			;ABORT	     (D7 1=TRUE)
ROTRHT	=2406			;ROTATE RIGHT(D7 1=TRUE)
ROTLFT	=2407			;ROTATE LEFT (D7 1=TRUE)
POTIN	=2C00			;POT VALUE   (D7 TO D0)
;
MJRVG	=4500			;MAJOR SCAPE VCTRS
MJRLST	=44F0			;MAJOR SCAPE SECTION JSRLS
TBVCTR	=4700			;MAJOR SCAPE LANDING SITES VCTRS
F.ALPH	=4740			;FOREIGN PLAYER ALPHA'S
;	OPTIONS
OPT0	=2800			;OPTIONS 1,0 BITS D1,D0 (COIN MODES)
OPT1	=OPT0+1			;OPTIONS 3,2 BITS D1,D0 (D0=FREE PLAY)
OPT2	=OPT1+1			;OPTIONS 5,4 BITS D1,D0 (FOREIGN LANG)
OPT3	=OPT2+1			;OPTIONS 7,6 BITS D1,D0 (COIN MECH #2)
;
;	PROGRAM ADDRESS
;
PROG	=6000
;
;VG ROM ADDRS. (LUNVEC - LUNARMAJOR & MODULES)
;
SHIPS	=4BA2		;MODULE JSRL'S
ATRMOD	=SHIPS+12	;ATTRACT MODULE LABS POSITION
LUNMJ0	=ATRMOD+8	;MAJOR SCAPE SECTION JSRL'S

LNMJR	=LUNMJ0+12	;LUNAR MAJOR HALF-SECTION LABS'
FINI	=LNMJR+10	;BEAM REST LABS & HALT
LTLMOD	=FINI+216	;LITTLE MODULES JSRLS'

TBLABS	=LTLMOD+12	;MAJOR SCAPEBONUS SITES' LABS
TBMNA	=TBLABS+3C	;MINOR SCAPE BONUS SITES' LABS
TBMNV	=TBMNA+3C	;MINOR SCAPE BONUS SITES' VCTRS
OCTGN	=TBMNV+20	;SHIP OCTAGON PICTURES (USED IN EXPLOSIONS)
BOOMB1	=OCTGN+4E	;EXPLOSION PIECES #1
BOOMB2	=BOOMB1+12.	;     "       "   #2
BOOMB3	=BOOMB2+12.	;     "       "   #3
BOOMB4	=BOOMB3+12.	;     "       "   #4
;
;VG ROM ADDRS. (LUNMIN - LUNARMINOR, MESSAGES, EXPLOSION PICTURES)
;
LNMIN	=51BA		;MINOR SCAPE SECTION JSRL'S
MINTBL	=LNMIN+28	;MINOR SCAPE SECTION LABS'
MINTAB	=MINTBL+40	;MINOR SCAPE SCROLL VALUE TABLE
MJSTRA	=MINTAB+0DC	;MAJOR SCAPE STARFIELD JSRL'S
MJSTRB	=MJSTRA+10
MINSTR	=MJSTRB+0E0	;MINORSCAPE STARFIELD SECTION JSRL'S
MINSVG	=MINSTR+28	;MINORSCAPE SECTION LABS
MESSG	=MINSVG+40	;JSRL TO PLAYER ALPHA STRINGS
MSSGLBS	=MESSG+0B6	;MESSAGE LABS'
DATAVG	=MSSGLBS+30	;PLAYER NUMERICAL DATA OFFSET VCTRS
XARROW	=DATAVG+1E	;JSRL'S TO HORIZONTAL ARROWS
YARROW	=XARROW+6	;JSRL'S TO VERTICAL ARROWS
STARRW	=YARROW+4A
WAIT7	=STARRW+4
VGMSGA	=WAIT7+1F4	;CHARACTER JSRL'S
;
FTBLNG	=5800		;FOREIGN LANGUAGES TABLE OFFSET(S)
FORMSG	=FTBLNG+4	;FOREIGN LANGUAGE POINTERS
FMESSG	=5E69		;PLAYER DATA
F.MIDX	=5FA1
F.MOFF	=5FA4		;CRASH/LAND MESSAGE OFFSET TABLE (FOREIGN)
;
;I/O DEFINITIONS
;
CNCNTR	=20			;COIN COUNTER BIT
NCNCNTR	=^CCNCNTR		;NOT COIN COUNTER BIT
NSPITC	=8			;HIGH FREQ NOISE PITCH BIT (EXPLOSION)
;
;	GLOBAL ENTRY POINTS
;
	.GLOBL	START,BMNBLK,DSPLAA,SCRLD2,DECIMAL,DECCNV,DIGITS,DIGT2S,DIGTYS,NMI
	.GLOBL	L.LED,S.SND

	.GLOBL	LEDS,VGON,TESTSW,NOISE,POTIN,STARTSW,WATCH,ENGMSG,E.MOFF,OPT3

	.GLOBL	RAMPTR,RAMLD,POINTR,TSFLAG,SWITCH,OLDSW,POTVAL,POTMIN
	.GLOBL	PTRNGE,POTUSE,INTCNT,INTFLG,GAMODE,TIMVAL,TIMER,FLMIN
	.GLOBL	GMTIME,VGCOUNT,NOISZP,TEMP6,NUMB1,NUMB2,NUMB3,LABPTR,LANG
	.GLOBL	TEMP1,TEMP2,TEMP3,INDEX,TEST,ARRWX,ARRWY,PTRTMP,LAMPZP
	.GLOBL	VGLIST,VGBRIT,XCOMP,SOFT.0,SOFT.1,VGCOUNT,D.SCNT,FRAME,C.OPT
	.GLOBL	OFFSET,DELX,DELY,SCROLL,SCRADD,M2.OPT

	.GLOBL	VGVCTR,VGADD,VGHEX,VGHEXZ,PWRON,LOADRAM,LODRM8,LODRM2,LODRM4
	.GLOBL	LDRAM4,LDRAM,DSPATTR,MESSAGE,MESSRG,MESSFU,MESSLAB,C.MEC2
	.GLOBL	SCRLDO,SCRLOAD,SCRLD1,SCRLD2

	.GLOBL	VGMSGA,INITSTK,SOFTWD,FRMECNT,CNCNTR,NCNCNTR,FLFACT,SECCNT
	.PAGE
	.=0000
SOFT.0:	.BLKB	1		;SOFTWARE WATCHDOG BYTE
THRUST:	.BLKB	1		;ROCKET THRUST X.05
SHIP:	.BLKB	1		;SHIP ROTATION (0-31)
SHPINE:	.BLKB	2		;INERTIA SHIP VALUE
INERTIA:.BLKB	2		;INERTIA FLAG
XCURADJ:.BLKB	4		;SHIP X POSITION (ADJUSTED)
YCURADJ =XCURADJ+2		;SHIP Y POSITION (ADJUSTED)
THRSTLV:.BLKB	2		;THRUST LEVEL (FOR FRAC)
YCURR:	.BLKB	8.		;SHIP Y-COMP. POSITION [LABS]
XCURR	=YCURR+2		;SHIP X-COMP. POSITION
MDWAIT	=XCURR+2		;VG WAIT (FOR LABS)
XPRE:	.BLKB	4		;PREVIOUS X DECODE VALUE
YPRE	=XPRE+2			;PREVIOUS Y DECODE VALUE
XPOS:	.BLKB	4		;CURRENT X DECODE VALUE
XCOMP	=XPOS			;4 BYTES FOR VGVCTR ROUTINE
YPOS	=XPOS+2			;CURRENT Y DECODE VALUE
XPOLAN:	.BLKB	4		;POS X LAND VAL
YPOLAN	=XPOLAN+2		;POS Y LAND VAL
LANG:	.BLKB	1		;LANGUAGE NUMBER
				;0 = ENGLISH
				;1 = FRENCH
				;2 = SPANISH
				;3 = GERMAN
GAMODE:	.BLKB	1		;GAME MODE 0=ATTRACT
				;	  10=FREE PLAY
				;	  20=RTP
				;	  40=PLAY
				;	  80=LAND
PLYMOD:	.BLKB	1		;PLAY MODE 0=EASY
				;3=DIFFICULT
TYPCNT:	.BLKB	1		;DEBOUNCE TIMER (GAME TYPE SWITCH)
STRTCNT:.BLKB	1		;DEBOUNCE TIMER (START SWITCH)
D.SCNT:	.BLKB	1		;DIAG STEP DEBOUNCE
RAMPTR:	.BLKB	2		;POINTER INTO V.G. RAM
VGLIST	=RAMPTR
PTRTMP:	.BLKB	2		;RAMPTR TEMPORARIES
POINTR:	.BLKB	2		;VCTR DECODE POINTER
RAMLUN:	.BLKB	2		;VG RAM LUNARSCAPE POINTER
LABPTR:	.BLKB	2		;MESSAGE LABS POINTER
TBLADDR:.BLKB	2		;TABLE ADDR POINTER
TABSIT:	.BLKB	4		;TABLE OF BONUS SITES
TEMP1:	.BLKB	2		;TEMPORARY
TEMP2	=TEMP1+1		;TEMP
TEMP3:	.BLKB	2		;TEMP
TEMP4	=TEMP3+1		;TEMP
TEMP5:	.BLKB	2		;TEMP
TEMP6	=TEMP5+1		;TEMP
DELX:	.BLKB	2		;VCTR DECODE DELTA X
DELY:	.BLKB	2		;VCTR DECODE DELTA Y
EXP:	.BLKB	1		;VCTR DECODE TIMER
MULTR:	.BLKB	1		;MULTIPLIER
MULTC:	.BLKB	1		;MULTIPLICAND
PROD:	.BLKB	2		;PRODUCT
SGNTRX:	.BLKB	1		;D7=SIGN XTHRUST
SGNTRY:	.BLKB	1		;D7=SIGN YTHRUST
SUMSOR:	.BLKB	2		;SOURCE VALUE
SUMDES:	.BLKB	2		;DESTINATION VALUE
SSORSGN:.BLKB	1		;SOURCE SIGN
SDESSGN:.BLKB	1		;DESTINATION SIGN
LUNARNUM:.BLKB	1		;LUNARSCAPE NUMBER
LUNAROT:.BLKB	15.		;LUNARSCAPE ROTATE
SCROLL	=LUNAROT+1		;SCROLL FACTOR (SCROLL+1=0 TO 255., SCROLL=FRACTION)
SCRADD	=SCROLL+2		;VERTICAL SCROLL FACTOR
MJRFLG	=SCRADD+3		;LUNAR SCAPE SCROLL FLAG
INDEX	=MJRFLG+1		;EXPLOSION SEQUENCE/ABORT SEQUENCE COUNTER
;	=MJRFLG+2		MJRFLG FOR VERTICAL (Y AXIS) SCROLL
XTHRUST	=MJRFLG+3		;THRUST X (ACCELERATION)
YTHRUST	=XTHRUST+1		;THRUST Y (     "      )
SGNVLX	=YTHRUST+1		;D7=SIGN VELX
SGNVLY	=SGNVLX+2		;D7=SIGN VELY
COLFLG	=SGNVLX+3		;COLLISION FLAG
				; 80= GOOD LANDING
				; C0= HARD LANDING
				; 8F= CRASH
VELX:	.BLKB	4		;VELOCITY X
VELY	=VELX+2			;VELOCITY Y
M.CLFL:	.BLKB	1		;MOTION COLLISION FLAG
GRAVITY:.BLKB	1		;GRAVITY
RAMLD:	.BLKB	2		;VG RAM LOAD SOURCE
ROT:	.BLKB	2		;ROTATE SHIP DEBOUNCE
RSTDEB:	.BLKB	1		;RESET SWITCH DEBOUNCE
STACK:	.BLKB	2		;STACK POINTER [DECODE]
STKSPCE:.BLKB	8		;STACK SPACE [DECODE]
INTFLG:	.BLKB	1		;INTERRUPT FLAG
INTCNT:	.BLKB	1		;INTERRUPT COUNTER
DIVSOR:	.BLKB	1		;DIVISOR
QUOT:	.BLKB	2		;QUOTIENT
MQ:	.BLKB	1		;TEMP QUOTIENT
DISTXL:	.BLKB	8		;DISTANCE X LEFT
DISTXR	=DISTXL+2		;DISTANCE X RIGHT
DISTYL	=DISTXR+2		;DISTANCE Y LEFT
DISTYR	=DISTYL+2		;DISTANCE Y RIGHT
DISTFLG:.BLKB	1		;DISTANCE FLAG
POTVAL:	.BLKB	1		;THRUST POT VALUE
POTMIN:	.BLKB	1		;THRUST POT MIN
PTRNGE:	.BLKB	1		;THRUST POT MAX
POTUSE:	.BLKB	1		;POT USAGE CNTR
FRAME:	.BLKB	1		;FRAME COUNTER
TIMVAL:	.BLKB	1		;FRAME/SECOND COUNTER
LAMPZP:	.BLKB	1		;MIRROR LAMP OUTPUT PORT
NOISZP:	.BLKB	1
VGCOUNT:.BLKB	1		;VG REFRESH COUNT
OFFSET:	.BLKB	2		;TABLE OFFSET VARIABLES
TIMER:	.BLKB	1		;PLAY MODE TIMER
BNFACT:	.BLKB	1		;BONUS FACTOR (ON GOOD LANDING)
VGBRIT:	.BLKB	1		;VARIABLE FOR VGVCTR (BRIGHTNESS)
MSCNT1:	.BLKB	1		;MESSAGE COUNTER
RNDOM:	.BLKB	1		;MESSAGE RANDOM VARIABLE
NUMB1:	.BLKB	3		;DECIMAL CONVERSION VARIABLES
NUMB2	=NUMB1+1
NUMB3	=NUMB2+1
FLDED:	.BLKB	2		;FUEL LOST
CRDTFLG:.BLKB	1		;CREDIT FLAG (0FF=CREDIT, 0=NO CREDIT)
C.OPT:	.BLKB	1		;COIN OPTION
M2.OPT:	.BLKB	1		;COIN MECH #2 SELECT
;
;	PLAYER DISPLAY DATA
;
ARRWX:	.BLKB	1		;VELOCITY X ARROW
ARRWY:	.BLKB	1		;VELOCITY Y ARROW
GMTIME:	.BLKB	8		;GAME TIME
FLMIN=	GMTIME+2		;FUEL MINIMUM
FLUSE=	FLMIN+3			;FUEL USED 
SCORE:	.BLKB	2		;GAME SCORE
VELOCX:	.BLKB	3		;VELOCITY X
VELOCY:	.BLKB	3		;VELOCITY Y
FUEL:	.BLKB	3		;FUEL
ALTITD:	.BLKB	3		;ALTITUDE
;
;	COIN ROUTINE VARIABLES
;
$CCTIM:	.BLKB	1		;COIN CNTR TIMER
$PSTSL:	.BLKB	1
$LMTIM:	.BLKB	1
	.BLKB	1		;$PSTSL FOR 2ND MECH
$CNCT:	.BLKB	4
$CNSTT	=$CNCT+1
$INTCT:	.BLKB	1		;INT CNTR LONG STRING TIMER
;
TEST:	.BLKB	1		;DIAG TEST #
TSFLAG:	.BLKB	1		;SELF TEST & DIAG FLAG
SWITCH:	.BLKB	2		;INPUT SWITCH VAR. (FOR SELF TEST)
OLDSW:	.BLKB	2		;OLD INPUT SWITCH VAR. (FOR SELF TEST)
SOFT.1:	.BLKB	2		;SOFTWARE STACK WATCHDOG BYTES
;
	.GLOBL	$CCTIM,$PSTSL,$LMTIM
	.GLOBL	$CNCT,$CNSTT,$INTCT,MOOLAH
	.PAGE
	.=6000
;
	.SBTTL	CHKSUM #6 (6000 - 63FF)  [20]
	.BYTE	0
;
	.SBTTL	POWER ON & MAIN LOOP
;
START:	JSR	ATRINIT		;INITIALIZE FOR ATTRACT
	LDA	I,80
	STA	COLFLG		;SET COLFLG FOR INITIAL CALL TO TRANS 
				;TO SET UP LUNAR MAJOR SCAPE
DOGAME:	BIT	CRDTFLG		;CHK FOR CREDIT
	BMI	10$
	LDA	I,0		;NO CREDIT [ATTRACT]
	STA	GAMODE
	STA	CRDTFLG		;CLR CREDIT
	BIT	COLFLG
	BPL	MAINLP
	JSR	ATRINIT
	BNE	MJRCON		;ALWAYS
10$:	LDA	GAMODE		;WHAT MODE WERE WE IN ?
	BNE	PLYSTRT		;BRANCH - WAS MOTION (GO TO PLAY MODE)
	JSR	ATRINIT		;IN CASE OF FREE PLAY
				;ELSE - INITIALIZE FOR RTP
				;SET EASY GAME TYPE LED
	LDA	I,0F0		;LEAVE TOP NIBBLE
	LDX	I,8		;TURN ON LED (EASY)
	JSR	L.LED		;SET LEDS & ZP STAT
	LDX	I,0
	STX	PLYMOD		;GAME TYPE IS EASY
	STX	SCORE		;CLR SCORE
	STX	SCORE+1
	LDA	I,11
	STA	GRAVITY
	LDA	I,20
	LDX	C.OPT		;CHECK-FREE PLAY?
	BNE	20$		;BRANCH-NO
	LSR			;ACC=^10
20$:	STA	GAMODE		;GAME MODE IS RTP
	BNE	MJRCON		;ALWAYS
PLYSTRT:JSR	PLYINIT
MJRCON:	JSR	TRANS		;CONSTRUCT MAJOR SCAPE
	LDX	I,2C		;JSRL FOR ALPHAS
	LDY	I,0CA
	LDA 	LANG		;CHK LANG #
	BEQ	5$
	LDX	I,0A0		;FOREIGN
	LDY	I,0C3		;ALPHA DATA (@ 4740 IN VG RAM)
5$:	LDA	GAMODE		;CHECK RTP
	AND	I,20
	BEQ	10$		;BRANCH - NOT RTP
	LDX	I,0		;ELSE - NO PLAYER DATA
	LDY	I,0F0		; INSERT BLANK ALPH
10$:	STX	A,VGRAM
	STY	A,VGRAM+1	;ADD JSRL [PLAYER INFO] TO VG RAM
MAINLP:	LDX	I,VGRAM+4/100	;ASSUME BUFFER 0 (4004)
	LDY	I,VGRAM+4&0FF
	LDA	FRAME
	LSR
	BCC	10$		;BRANCH - BUFFER 0 (4004)
	LDX	I,VGRAM+284/100	;BUFFER 1 (4284)
	LDY	I,VGRAM+284&0FF
10$:	STX	RAMPTR+1
	STY	RAMPTR
	LDA	GAMODE
	AND	I,20
	BNE	N.MOT1		;BRANCH - RTP
	JSR	MESDATA		;NUMERICAL DATA
	JSR	SCAPE		;DISPLAY LANDSCAPE
	JSR	STARS		;DISPLAY STARFIELD
	JSR	MODULE		;DISPLAY MODULE
	LDA	GAMODE		;CHECK FREE PLAY
	AND	I,10		;BIT 4=FREE PLAY
	BNE	N.MOT1		;BRANCH-FREE PLAY
	BIT	GAMODE
	BPL	N.MOT2		;BRANCH - NOT MOTION (ATTRACT OR PLAY)
	LDA	M.CLFL
	AND	I,0F
	BEQ	MOTNA		;BRANCH - NOT CRASH
MOTION:	LDA	PTRTMP		;ELSE - PTRTMP = LABS FOR MODULE
	STA	RAMPTR		;		= ORIGIN OF EXPLOSION
	LDA	PTRTMP+1
	STA	RAMPTR+1
	JSR	BOOM		;DISPLAY EXPLOSION SEQUENCE
MOTNA:	JSR	DSPMOT		;DISPLAY MOTION MESSAGES
	JMP	BMREST		;REST VG BEAM @ CNTR
N.MOT1:	JSR	DSPRTP		;DISPLAY RTP MESSAGES
	JMP	BMREST
N.MOT2:	JSR	FLAME
	BIT	GAMODE
	BVC	10$		;BRANCH - NOT PLAY
	LDA	PLYMOD
	BNE	5$		;BRANCH - NOT EASY PLAY MODE
	LDA	FRAME
	AND	I,0F
	CMP	I,8
	BNE	5$
	JSR	FRICTN		;EASY GAME PLAY =FRICTION
5$:	JSR	STATUS		;DISPLAY FUEL STATUS [PLAY]
	JSR	SITES		;FLASH BONUS SITES
	JMP	BMREST		;REST VG BEAM @ CNTR
10$:	JSR	DSPATTR		;DISPLAY ATTRACT MESSAGES
BMREST:	LDY	I,FINI&0FF	;VG BEAM @ CNTR (REST & HALT)
	LDA	I,FINI/100
	LDX	I,6
	JSR	LOADRAM
;
;
	LDA	A,TESTSW
	AND	I,2
2$:	BEQ	2$		;SELF TEST SWITCH, WAIT FOR WATCHDOG
	JSR	INTWAIT		;WAIT FOR END OF FRAME
	LDY	I,2
	LDX	I,0F0		;ASSUME BUFFER 0 (4004)
	LDA	FRAME
	LSR
	BCC	3$		;BRANCH - BUFFER 0
	LDX	I,0E1		;ELSE - BUFFER 1 (4284)
	LDY	I,042		;LOW BYTE OF JMPL
3$:	STX	A,VGRAM+3	;SET JMPL OR ALPH (BYTE 1)
	STY	A,VGRAM+2	;SET BYTE 1 (FOR JMPL OR ALPH)
	STA	A,VGON		;START VG
	INC	FRAME
;
;
	LDX	I,0		;ASSUME NO SOUND
	LDA	A,TESTSW	;CHK SLAM
	AND	I,4
	BNE	4$		;BRANCH - NO SOUND
	LDX	I,20		;SND FOR SLAM
4$:	LDA	I,1F		;AND MASK
	JSR	S.SND		;SET SND
	JSR	CREDIT		;GIVE CRDT
	JSR	THRLVL		;THRUST LEVEL CALCULATION
	BIT	GAMODE
	BMI	FRMEND		;BRANCH - MOTION
	BVC	10$		;BRANCH - NOT PLAY
	JSR	FRCMLT		;THRUST X,Y VECTORS
	JSR	ROTSHP		;ROTATE SHIP
	JSR	BURN		;BURN FUEL [THRUST]
	JSR	DISPLY		;GENERATE PLAYER INFO (PLAY)
;
	LDA	THRUST		;PLAY MODE THRUST SOUND
	CMP	I,10		;CHECK FOR ABORT
	BNE	5$		;BRANCH - NOT ABORT
	LDA	I,0F		;FOR ABORT MAX THRUST SOUND
5$:	LSR
	ORA	I,1		;MIN SOUND
	TAX
	LDA	I,30		;AND MASK
				;SOUND LEVEL = THRUST/2 + 1
	JSR	S.SND		;SET NOISE
;
	BNE	30$		;ALWAYS
10$:				;NO SOUND - ATTRACT & RTP
	LDA	I,20		;JUST SLAM SW SOUND
	LDX	I,0		;DON'T SET ANY SOUNDS
	JSR	S.SND		;SET NOISE
20$:	LDA	GAMODE
	AND	I,20
	BNE	FRMEND		;BRANCH - RTP
				;ATTRACT (OR FREE PLAY)
30$:	JSR	ACCEL		;ACCELERATE (MOVE) MODULE
	JSR	DECODE		;DISTANCE DECODE
	JSR	SCAPCHG		;LUNARSCAPE CHANGE
FRMEND:	LDA	GAMODE
	BEQ	ATRCHK		;ATTRACT
	JSR	TYPE		;SET GAME TYPE [NOT IN ATTRACT]
	BIT	GAMODE
	BMI	MOTCHK		;MOTCHK
	BVS	PLYCHK
RTPCHK:	LDX	I,0		;FLASH START/SELECT LEDS
	LDA 	FRAME
	AND	I,10		;ON/OFF 16. FRAMES
	BNE	5$
	LDX	I,10		;NOT (BIT 4) SETS LEDS
5$:	LDA	I,0F
	JSR	L.LED		;SET LEDS & ZP STATUS BYTE
	BIT	A,STARTSW	;CHECK START SWITCH
	BMI	10$		;BRANCH - START SWITCH PUSHED
	LDA	I,40		;ELSE - INITIALIZE DEBOUNCE COUNT
	STA	STRTCNT
	BNE	15$		;ALWAYS
10$:	ASL	STRTCNT		;2 SHIFTS (2 FRAMES) = DEBOUNCE
	BCS	20$		;DEBOUNCED
15$:	BIT	COLFLG		;COLLISION?
	BPL	RTMAIN		;BRANCH-NO
	JSR	ATRINIT		;RESET MISSION
	LDA	I,10		;FREE PLAY
	STA	GAMODE
	BNE	RTMAIN
20$:	JMP	PLYSTRT		;INITIALIZE PLAYER ALPH. DATA & MAJOR
RTMAIN:	JMP	MAINLP		;RETURN TO MAIN LOOP
MOTCHK:	BIT	M.CLFL		;CHECK FOR HARD LANDING
	BVC	10$		;NOT HARD (BRANCH)
	BIT	SGNVLY		;WAIT FOR MODULE FALL (- VELY)
	BPL	5$
	BIT	COLFLG		;THEN - CHECK FOR IMPACT
	BMI	10$		;IMPACT - BRANCH
5$:	JSR	ACCEL		;ELSE - ACCELERATE MODULE (MOVE)
	JSR	DECODE		;AND DECODE MODULE TO SCAPE DISTANCE
10$:	LDA	FRAME		;MOTION [LAND/CRASH]
	LSR
	BCS	RTMAIN
	INC	INDEX		;STEP THROUGH LAND/CRASH SEQUENCE
	BPL	RTMAIN
	ASL	INDEX		;INDEX=0
	LDA	M.CLFL		;SET TO INITIALIZE ATTRACT
	STA	COLFLG
ATRCHK:	JMP	DOGAME		;GO TO ATTRACT (PENDING CREDIT)
PLYCHK:	LDA	COLFLG		;PLAY
	BMI	10$
	JSR	ABORT
	BIT	CRDTFLG
	BMI	5$		;CONTINUE (PLAYER HAS CREDIT)
	LDA	TIMER
	CMP	I,5		;ATTRACT MODE AFTER 5 SECONDS
	BCC	2$
	JMP	START		;GO TO ATTRACT
2$:	JMP	MAINLP		;RETURN TO MAIN LOOP
5$:	BIT	A,ABORTSW	;RESET ONLY W/CREDIT
	BMI	7$
	LDA	I,40
	STA	RSTDEB		;INITIALIZE DEBOUNCE
	BNE	2$		;ALWAYS, RETURN TO MAINLP (NO RESET)
7$:	ASL	RSTDEB
	BCC	2$		;DEBOUNCE RESET (2 SHIFTS = 48. MS)
	LDA	I,ABTCNT
	STA	INDEX
	BNE	2$		;ALWAYS, RETURN TO MAINLP
10$:	JSR	LNDADR		;DO SCORING
	LDA	COLFLG
	STA	M.CLFL		;SET MOTION FLAG
	ASL
	BNE	20$
	LDY	I,BNFUEL/100	;GIVE BONUS FUEL ON GOOD LANDINGS
	LDA	I,BNFUEL&0FF
	JSR	GIVCRD
20$:	JSR	DEDUCT		;SUBTRACT LOST FUEL
	JSR	DELTA		;EXPLOSION DELTAS
	LDX	I,0
	STX	ALTITD		;ALTITUDE=0
	STX	ALTITD+1
	STX	ALTITD+2
	LDY	I,10.
30$:	STX	ZY,MJRFLG+2	;CLEAR SCAPE SCROLL FLAG
				;VELOCITIES
				;COLLISION FLAG
				;THRUST
	DEY
	BPL	30$
	LDA	I,20		;JUST SLAM SWITCH SOUND
	JSR	S.SND
	ASL	GAMODE		;GO TO LAND/CRASH
	LDA	I,1
	STA	INDEX		;INDEX SET FOR LAND/CRASH
	LDA	I,M.HRDY	;SET VELY IN CASE OF HARD LANDING BOUNCE
	STA	VELY+1
	LDA	I,M.HRDG	;SET GRAVITY IN CASE OF "    "      "
	STA	GRAVITY
	BNE	2$		;ALWAYS
	.PAGE
	.SBTTL	VARIABLE INIT
;
;INITIALIZE VARIABLES FOR ATTRACT
;
ATRINIT:STA	A,NSREST	;RESET NOISE CIRCUIT
	LDX	I,8
	STX	SHIP		;INITIALIZE SHIP ROTATION
10$:	LDA	AX,ATRMOD-1	;YCURR=SHIP INITIAL POSITION
	STA	ZX,YCURR-1	;  [LABS & WAIT FOR ATTRACT]
	DEX
	BNE	10$
	STX	VELY		;X=0, CLR Y VELOCITY
	STX	VELY+1
	LDA	I,11		;INITIALIZE GRAVITY
	STA	GRAVITY
	LDA	INTCNT		;RANDOM X VELOCITY
	STA	VELX+1
	LDX	I,3
20$:	LDA	AX,INTXCUR
	STA	ZX,XCURADJ	;INITIALIZE SHIP X & Y ADJUSTED POSITION
	DEX
	BPL	20$
	BMI	REINIT		;RESET VARIABLES (ALWAYS)
;
;INITIALIZE VARIABLES FOR GAME PLAY
;
PLYINIT:LDA	INTCNT		;SET UP BONUS SITES
	AND	I,3		;FIRST SITE = 0 TO 3
	STA	TABSIT
	CLC
	ADC	I,1
	AND	I,3
	STA	TABSIT+1	;SECOND SITE = 0 TO 3 (= TABSIT+1)
	LDA	INTCNT
	LSR
	LSR
	AND	I,0F
	CMP	I,0F
	BNE	10$
	LDA	I,4		;SET 15. TO 4
10$:	JSR	BNSITE		;CALCULATE BONUS SITE
	STA	TABSIT+2	;THIRD SITE = 4 TO 14.
	EOR	I,0F
	JSR	BNSITE		;CALCULATE
20$:	STA	TABSIT+3	;FOURTH SITE = 4 TO 14.
	LDX	I,3
30$:	LDA	AX,INVELX	;INITIALIZE VELOCITIES
	STA	ZX,VELX
	LDA	AX,INTXCUR	;INITIALIZE POSITION
	STA	ZX,XCURADJ
	LDA	AX,WAIT7
	STA	ZX,MDWAIT
	DEX
	BPL	30$
	LDA	I,0
	TAX			;X = 0
	LDY	I,7		;VAR COUNTER
40$:	STX	ZY,GMTIME	;CLR MISSION TIME
				;CLR MINIMUM FUEL
				;CLR FUEL USED
	DEY
	BPL	40$
	LDA	I,40
	STA	GAMODE		;SET GAME MODE
				;TURN START/SELECT LAMP ON
	LDA	I,0F
	JSR	L.LED		;SET LEDS & ZP STAT
	LDA	I,16.
	STA	SHIP		;SHIP ROTATION
	JSR	TYPLP
				;CONTINUE
;
REINIT:	LDX	I,0		;CLR VARIABLES - - -
	LDY	I,14.
5$:	STX	ZY,LUNAROT	;SCAPE ROTATION (SCROLL)
				;SCROLL (VERTICAL & HORIZONTAL)
				;SCAPE SCROLL FLAGS (VERT & HORZ)
				;ABORT/CRASH EVENT COUNTER
				;THRUST
				;COLLISIONS
				;VELOCITY SIGNS
	DEY
	BPL	5$
	DEX			;X=0FF
	LDY	I,7
10$:	STX	ZY,DISTXL	;SET SHIP TO SCAPE DISTANCES @ MAX
	DEY
	BPL	10$
	LDA	I,40
	STA	LUNARNUM	;DISPLAY MAJOR SCAPE
	RTS
;
BNSITE:	CMP	I,4
	BCS	10$		;CHK MINIMUM OF SITE
	ADC	I,1		;CARRY IS CLR
	ORA	I,0A		;MAP TO ^A,^B,^E
10$:	RTS
;
GRAVT:	.BYTE	11,11,22,11	;GRAVITIES FOR GAME TYPES
	.PAGE
	.SBTTL	ROUTINES FOR SWITCH SELECTABLE CONDITIONS
;
;CHECK GAME TYPE SWITCH
;
TYPE:	BIT	A,TYPESW
	BPL	TYPSET		;BRANCH - GAME TYPE NOT PRESSED
	ASL	TYPCNT		;2 ROTATIONS = DEBOUNCE (= 48 MS.)
	BCC	TYPEXT		;NOT YET DEBOUNCED
10$:	INC	PLYMOD		;INCREMENT TO NEXT PLAY OPTION
	LDA	PLYMOD
	AND	I,3		;ROTATE THROUGH 4 OPTIONS (0 1 2 3)
	STA	PLYMOD		;CHANGE GAME TYPE
TYPLPA:	LDA	SHIP
TYPLP:	ASL
	ASL
	STA	ROT+1		;SET ROTATIONAL VALUE
	LDA	I,0
	STA	SHPINE
	STA	SHPINE+1
	STA	INERTIA		;CLR INERTIA FLAGS
	STA	INERTIA+1
	STA	ROT
	LDX	PLYMOD
	LDA	AX,GRAVT	;LIKEWISE W/GAME TYPE GRAVITY
	STA	GRAVITY
	LDA	AX,MODLMP	;SET PROPER GAME TYPE LAMP
	TAX
	LDA	I,0F0
	JMP	L.LED		;SET LEDS & ZP STAT
TYPSET:	LDA	I,40		;RESET DEBOUNCE COUNT
	STA	TYPCNT
TYPEXT:	RTS
;
MODLMP:	.BYTE	8,4,2,1
;
;CHECK CREDIT [FREE PLAY]
;
CREDIT:	JSR	C.MEC2		;SET M2.OPT VARIABLE
	BNE	10$		;BRANCH - NOT FREE PLAY
	BIT	CRDTFLG		;CHK BIT 6 (SET IF CREDIT OR PLAY MODE)
	BVS	10$
	JSR	CRED.A		;ELSE - GIVE CREDIT FOR FREE PLAY
10$:	LDX	$CNCT		;ANY COINS IN MECH #1 ?
	BEQ	20$		;BRANCH - NO, NOT YET
	DEC	$CNCT		;DECREMENT COIN COUNT (MECH #1)
	JSR	CRED.A		;GIVE CREDIT
20$:	LDX	$CNCT+2		;ANY COINS IN MECH #2
	BEQ	40$		;BRANCH - NONE
	DEC	$CNCT+2		;ELSE - DEC COIN COUNT (MECH #2)
30$:	JSR	CRED.A		;GIVE CREDIT
	DEC	M2.OPT		;REPEAT FOR MECH #2 SELECT COUNTS
	BNE	30$
40$:	RTS			;DONE
;
CRED.A:	LDX	C.OPT		;X = 2*COIN OPTION (= CREDIT TABLE OFFSET)
	LDA	AX,CRDTBL	;ACC = LOW BYTE OF CREDIT (FUEL) VALUE
	LDY	AX,CRDTBL+1	;Y   =  "   "    "    "     "      "
				;CONTINUE TO GIVCRD
;
;	Y,ACC = HI,LO BYTES TO ADD TO FUEL LEVEL
;	@ EXIT FUEL+1,FUEL+2 INCREASED BY ACC,Y (FUEL = FRACTIONAL BYTE)
;
GIVCRD:	LDX	I,0FF		;INDICATE CREDIT
	STX	CRDTFLG
	SED
	CLC
	ADC	FUEL+1		;ADD CREDIT TO FUEL
	TAX
	TYA
	ADC	FUEL+2
	CLD
	BCC	10$		;BRANCH - NO OVERFLOW
	LDA	I,99		;ELSE - MAX CREDIT=9999.
	TAX
10$:	STA	FUEL+2
	STX	FUEL+1
	RTS
;
;	CREDITS TABLE
;
CRDTBL:	.WORD	900		;FREE PLAY
	.WORD	450
	.WORD	600
	.WORD	750
	.WORD	900

;
;CHECK ROTATE OF SHIP

;
ROTSHP:	LDA	INDEX
	BEQ	2$
	RTS			;NO ROTATE IN ABORT
2$:	LDA	PLYMOD		;CHECK FOR PLYMOD = 3
	CMP	I,3		; = ROTATIONAL INERTIA
	BEQ	3$		;BRANCH - INERTIA
	JMP	ROT.NI		;NOT ROTATIONAL INERTIA
3$:	LDA	ROT
	CLC
	ADC	SHPINE		;ADD IN INERTIA
	STA	ROT
	LDA	ROT+1
	ADC	SHPINE+1
	STA	ROT+1
	LSR
	LSR
	AND	I,1F
	STA	SHIP		;SHIP # = 1/4 * ROT+1
	LDY	I,0		;ASSUME NO MIN. OF INERTIA
	LDA	SHPINE
	LDX	SHPINE+1	;CHECK TOP BYTE
	BEQ	7$		;BRANCH - CHECK MIN +INERTIA
	INX			;X = 0FF ?
	BNE	10$		;BRANCH - NO
	CMP	I,0C0		;ELSE CHECK MIN -INERTIA
	BCC	10$		;BRANCH - NOT W/I INERTIA
5$:	DEY			;SET INERTIA FLAG
	BMI	10$		;ALWAYS
7$:	CMP	I,41		;CHECK +INERTIA WINDOW
	BCC	5$		;W/I WINDOW
10$:	STY	INERTIA		;SET MIN. INERTIA FLAG
	BIT	CRDTFLG
	BPL	ROTEXT		;ROTATE ONLY W/ CREDIT
	LDX	I,0		;CHK ROTATE SWITCHES
	JSR	ROTCHK		;CHECK ROTATE
	ASL
	ASL
	ASL
	ASL			;BIT D4=CHANGE
	LDY	I,0		;Y=TOP BYTE OF ADD
	AND	I,0F0
	BEQ	30$		;NO DEDUCT IF NO CHANGE
	BCC	15$		;ADD POSITIVE
	DEY			;Y=-TOP BYTE
15$:	CLC
	ADC	SHPINE
	TAX
	TYA
	ADC	SHPINE+1
	BPL	20$		;BRANCH - CHECK MAX +INERTIA
	CMP	I,0FC		;ELSE - CHECK MAX -INERTIA
	BCS	25$		;W/I MAX -INERTIA
	LDA	I,0FC
	LDX	I,0		;A,X = MAX -INERTIA
	BEQ	25$		;ALWAYS
20$:	CMP	I,4		;CHECK MAX +INERTIA
	BCC	25$		;BRANCH - W/I +INERTIA
	LDA	I,3
	LDX	I,0E0		;A,X = MAX +INERTIA
25$:	STA	SHPINE+1
	STX	SHPINE
	JMP	ROT.GAS		;DEDUCT FUEL
30$:	LDA	INERTIA		;CHECK MIN. INERTIA WINDOW
	BEQ	35$		;BRANCH - NOT MIN.
	LDA	INERTIA+1	;CHK PREVIOUS STAT
	BEQ	32$		;BRANCH - WAS = ZERO
	LDA	I,0
	TAX
	BEQ	33$		;ALWAYS (CLEAR INERTIA)
32$:	LDA	SHPINE
	ORA	SHPINE+1	;IS IT STILL ZERO ?
	BEQ	35$		;BRANCH - YES
	LDA	I,050		;ASSUME +
	LDX	I,0
	BIT	SHPINE+1
	BPL	33$		;ELSE -
	LDA	I,0B0
	DEX
33$:	STX	SHPINE+1	;CLR INERTIA
	STA	SHPINE
35$:	LDA	SHPINE
	ORA	SHPINE+1	;SET PREVIOUS STATE
	STA	INERTIA+1	;0 IF NO INERTIA
ROTEXT:	RTS
ROT.NI:	BIT	CRDTFLG
	BPL	ROTEXT		;ROTATE ONLY W/ CREDIT
	LDX	ROT+1
	JSR	ROTCHK
	CPX	ROT+1
	BEQ	ROTEXT		;BRANCH - NO ROTATION CHANGE
	STX	ROT+1		;UPDATE ROTATION #
	LSR
	LSR
	AND	I,1F
	STA	SHIP
	LDA	PLYMOD		;CHECK GAME PLAY VERSION
	AND	I,3
	BNE	ROT.GAS		;NOT=0
	LDX	ROT+1		;EASY VERSION (PLYMOD D1,D0=00)
	CPX	I,0FF		;LIMIT ROTATION TO LOWER HEMISPHERE (0<= ROT+1 <=^40)
	BEQ	30$		;ACC = 0
29$:	CPX	I,41		;0 < ROT+1
	BNE	ROT.GAS		;DEDUCT FUEL FOR LEGAL ROTATIONS
	LDA	I,10		;X=^10 (MAX LEFT ROTATION)
30$:	STA	SHIP		;SET SHIP ROTATION
	ASL
	ASL
	STA	ROT+1		;SET ROTATION VALUE (ROT. DEBOUNCE)
	BCC	ROTEXT		;ALWAYS (NO FUEL USE @ MAX & MIN)
ROT.GAS:LDX	I,0		;ONE SHIP ROTATION COST 1/4 FUEL UNIT
	LDY	I,6
	JMP	GASA
;
ROTCHK:	BIT	A,ROTRHT	;CHECK RIGHT ROTATE
	BPL	10$
	DEX			;ROTATE RIGHT
10$:	BIT	A,ROTLFT	;CHECK LEFT ROTATE
	BPL 	20$
	INX			;ROTATE LEFT
20$:	TXA			;FOR CHECK
	RTS
;
;	DETERMINE PROPER THRUST
;
THRLVL:	BIT	GAMODE
	BVC	10$		;BRANCH - NOT PLAY
	LDA	INDEX		;CHECK ABORT MODE
	BNE	50$		;BRANCH - ABORT
10$:	LDA	PTRNGE
	LSR
	LSR
	TAX			;MIN WINDOW = 1/4*RANGE
	LSR
	STA	TEMP1		;MAX WINDOW = 1/8*RANGE
	LDY	I,0
	CPX	POTVAL
	BCS	20$		;VALUE < MIN WINDOW
	LDA	PTRNGE
	SEC
	SBC	POTVAL
	LDY	I,0F
	BCC	20$		;PROTECT FOR RANGE REDUCTION (BY POTUSE)
	CMP	TEMP1
	BCC	20$		;WITHIN MAX WINDOW
	LDA	POTVAL
	LDY	PTRNGE
	JSR	DIVIDE
	TXA			;A = POT RANGE FRACTION
	LSR
	LSR
	LSR
	LSR
	TAY			;Y = THRUST (1 OUT OF 16)
20$:	STY	THRUST
	LDY	I,0		;TO CLR VARIABLES LATER
	LDA	POTUSE
	CMP	I,75.		;CHK POT USE
	BCC	30$
	INC	POTMIN		;REDUCE RANGE
	DEC	PTRNGE
	DEC	PTRNGE
	STY	POTUSE		;CLR POTUSE
30$:	BIT	CRDTFLG		;CLR THRUST W/O CREDIT
	BPL	40$
	LDA	GAMODE
	BNE	50$		;BRANCH - NOT ATTRACT
40$:	STY	THRUST		;NO THRUST
50$:	RTS
;
GASA:	LDA	I,0
GAS:	SED
	STA	TEMP1+2		;SUBTRACT [A],[X], & [Y] FROM [FUEL+2],[FUEL+1], & [FUEL]
	STX	TEMP1+1
	STY	TEMP1
	LDA	FUEL
	SEC
	SBC	TEMP1
	TAY
	LDA	FUEL+1
	SBC	TEMP1+1
	TAX
	LDA	FUEL+2
	SBC	TEMP1+2
	BCS	10$
5$:	BIT	CRDTFLG		;DON'T CLEAR TIMER TWICE
	BPL	20$		;NO CREDIT (ALREADY SET UP FOR ATTRACT RESTART)
	LDA	I,40
	STA	CRDTFLG		;INDICATE LOSS OF CREDIT (D6 SET FOR FREE PLAY)
	LDA	I,0
	STA	FUEL		;CLR FUEL BYTES
	STA	FUEL+1
	STA	FUEL+2
	STA	TIMER		;CLEAR TIMER FOR ATTRACT RESTART
	BEQ	15$		;ALWAYS
10$:	STY	FUEL
	STX	FUEL+1
	STA	FUEL+2
	ORA	FUEL+1
	BEQ	5$		;NO FUEL
15$:	CLC
	LDA	FLUSE		;FLUSE=FUEL USED
	ADC	TEMP1
	STA	FLUSE
	LDA	FLUSE+1
	ADC	TEMP1+1
	STA	FLUSE+1
	LDA	FLUSE+2
	ADC	TEMP1+2
	STA	FLUSE+2
20$:	CLD
	RTS
;
;
;
ABORT:	LDA	INDEX		;CHECK FOR ABORT
	BEQ	99$
	BIT	CRDTFLG
	BPL	100$		;STOP ABORT IF NO CREDIT
	LDA	FRAME
	LSR
	BCC	20$
	LDA	SHIP		;ROTATE SHIP TO VERTICAL (#8)
	CMP	I,8		;EVERY OTHER FRAMES=48.MS
	BCC	10$		;SHIPS 0 TO 7
	BEQ	20$
	CMP	I,25.
	BCS	10$		;SHIPS 25 TO 31
	DEC	SHIP		;SHIPS 9 TO 24
	BNE	15$		;ALWAYS
10$:	CLC
	ADC	I,1
	AND	I,1F
	STA	SHIP
15$:	JSR	TYPLPA		;SET ROT & SHPINE (CLR INERTIA)
20$:	LDA	VELX+1
	BNE	25$
	STA	VELX
	BEQ	30$		;ALWAYS
25$:	DEC	VELX+1
30$:	LDA	SHIP
	CMP	I,8
	BNE	99$
	LDA	INDEX		;ALWAYS GIVE SOME THRUST
	CMP	I,ABTMIN
	BCS	40$		;BRANCH - NOT MIN THRUST YET
	BIT	SGNVLY		;CHK VELY
	BMI	40$		;BRANCH - MINUS
	LDA	VELY+1
	CMP	I,10		;CHK MAX POSITIVE Y VELOCITY
	BCC	40$		;BRANCH - NOT YET
	LDA	I,0		;MAX VELY=+31.
	BCS	102$		;ALWAYS
40$:	LDA	I,10		;SET THRUST TO ABORT LEVEL
	STA	THRUST
	DEC	INDEX
99$:	RTS
100$:	LDA	I,0		;OUT OF FUEL
	STA	THRUST		;CLR THRUST
102$:	STA	INDEX		;CLR ABORT
	RTS
;
;X&Y VELOCITY FRICTION
;
FRICTN:	LDX	I,2		;OFFSET FOR Y VELOCITY
5$:	LDA	ZX,VELX		;LOW BYTE
	STA	TEMP1
	LDA	ZX,VELX+1	;HIGH BYTE
	LDY	I,5		;DIVIDE * 2 (5 TIMES)
10$:	LSR			;DIVIDE BY 2
	ROR	TEMP1
	DEY
	BNE	10$		;REPEAT
	STA	TEMP1+1
	LDA	ZX,VELX		;SUBTRACT FRICTION FROM VELOCITIES
	SEC			; (VEL(X OR Y)-TEMP1)
	SBC	TEMP1
	STA	ZX,VELX
	LDA	ZX,VELX+1
	SBC	TEMP1+1
	STA	ZX,VELX+1
	DEX
	DEX
	BPL	5$
	RTS			;REPEAT FOR VELX
	.PAGE
	.SBTTL	 WAIT FOR EOF (END OF FRAME)
;
INTWAIT:LSR	INTFLG		;WAIT FOR FRAME FLAG (FROM INTERRPT)
	BCC	INTWAIT		;BRANCH-NOT YET
10$:	LDA	A,TESTSW	;HAS VG HALTED?
	LSR
	BCC	10$		;NO-KEEP CHECKING
	RTS
;
;
	.SBTTL	CHKSUM #7 (6400 - 67FF)  [1C]
	.BYTE	0
	.SBTTL	LUNARSCAPE, MODULE, AND FLAME

;
;DISPLAY LUNARSCAPE
;	INITIALIZED TO LUNMJR [ATRINIT & PLYINIT]
;ACCESSES SEVERAL TABLES;
;
;MINOR - MINTBL TABLE OF SCAPE SECTION ABSOLUTE BEAM
;	ORIGINS (SECTION = 256. ON Y AXIS)
;	LUNMIN TABLE OF JSRL'S TO MINOR SECTIONS
;GLOBE - LUNSCG (LNGLBA, LNGLBB) CONTAINS LABS, WAIT & JSRL
;	TO GLOBE PICTURE
;MAJOR - LUNMJ0 TABLE OF ABSOLUTE SCAPE SECTION ORIGINS
;	LUNSCP (LNSCPA, LNSCPB) TABLE OF JSRL'S TO MAJOR
;	SECTIONS.
;USES VARIABLES RAMLD, RAMPTR, TEMP1
;	ACCESSES SCRADD, SCROLL
;	ALL REGISTERS A,X,Y USED
;CALLS LOADRAM ROUTINE
;
;SCAPE LOADS VECTOR GENERATOR (VG) RAM WITH JSRL'S TO PROPER
;LUNARSCAPE PICTURES AND SETS UP SCROLLING OF SCAPE
;
SCAPE:	LDA	LUNAROT
	ASL
	STA	OFFSET+1
	ASL
	STA	OFFSET
	BIT	LUNARNUM	;CHECK LUNARSCAPE DISPLAYED
	BVS	MAJOR		;*** MAJOR
				;*** MINOR
	LDA	I,MINTBL&0FF	;LOAD LABS FOR CURRENT SCAPE
	LDX	I,MINTBL/100
	JSR	SCRLDO		;DO SCROLLING OF MINOR SCAPE
	LDA	I,LNMIN&0FF		;LOAD JSRL'S FOR SCAPE COMPOSITE
	LDX	I,LNMIN/100
	BNE	SCPLD			;ALWAYS BRANCH
MAJOR:	LDA	I,LUNMJ0&0FF
	LDX	I,LUNMJ0/100
	JSR	SCRLDO		;DO SCROLLING OF MAJOR SCAPE
	LDA	I,MJRLST&0FF	;LOAD JSRL'S FOR LUNAR
	LDX	I,MJRLST/100
SCPLD:	LDY	RAMPTR		;SET RAMLUN FOR DECODE
	STY	RAMLUN
	LDY	RAMPTR+1
	STY	RAMLUN+1
	BNE	STRLD		;ALWAYS (AND RETURN)
;
;	STARS LOADS LABS,WAIT & JSRL'S FOR PROPER
;	STAR FIELDS INTO VGRAM SPECIFIED BY RAMPTR,RAMPTR+1
;
STARS:	BIT	LUNARNUM	;CURRENT LUNARSCAPE
	BVC	STRMIN		;MINOR ...
				;MAJOR ...
	LDX	I,0A1
	JSR	STRINIT
	LDA	I,MJSTRA&0FF	;SCREEN STARS
	LDX	I,MJSTRA/100
				;STARS FOUND IN 0<-Y AXIS <- 767.
	JSR	STRLD		;DISPLAY LOWER MAJOR STARFIELD
	BIT	GAMODE
	BVS	10$		;DISPLAY TOP STARS IN PLAY MODE
	RTS
10$:	LDX	I,0A3
	JSR	STRINIT		;LOAD LABS & WAIT FOR TOP STARFIELD
	LDA	I,MJSTRB&0FF	;STARS IN 768. <- Y AXIS <- 1279.
	LDX	I,MJSTRB/100
	BNE	STRLD		;ALWAYS BRANCH
STRMIN:	LDA	I,MINSVG&0FF
	LDX	I,MINSVG/100
					;[OFFSET] SET IN SCAPE
	JSR	SCRLDO
	LDA	I,MINSTR&0FF
	LDX	I,MINSTR/100
STRLD:	CLC
	ADC	OFFSET+1		;[OFFSET+1] SET IN SCAPE
	TAY
	TXA
	ADC	I,0
	LDX	I,10.
	JMP	LOADRAM		;LOAD JSRL'S
;
STRINIT:LDA	I,0		;LABS FOR STARS
	STA	TEMP1		;STARTS @
	STA	TEMP1+2		; 0,[X&0F*256.] [VG DISPLAY]
	STA	TEMP1+3
	STX	TEMP1+1
	LDY	I,TEMP1&0FF
	JMP	SCRLOAD
;
;	MODULE LOADS JSRL FOR SHIP OR CONSTRUCTS PROPER
;	ROTATION BY INVERTING X OR Y OF THE VCTR INSTRUCTIONS
;
MODULE:	JSR	POSTMOD
	LDY	I,YCURR&0FF	;LOAD LABS FOR MODULE
	LDA	I,YCURR/100&0FF	;ACC = 0
	STA	DELX+1		;FOR FLAME
	STA	DELY+1
	JSR	LODRM8
	LDA	RAMPTR		;SAVE RAMPTR
	STA	PTRTMP		;IN CASE OF EXPLOSION
	LDA	RAMPTR+1
	STA	PTRTMP+1
	LDA	SHIP
	CMP	I,9
	BCS	10$		;NEED TO CALCULATE SHIP
				;STANDARD QUADRANT (-X, -Y)
	JSR	M.OFFS		;GET PROPER MODULE ADDRESS (TO JSRL)
	JMP	LODRM2		;LOAD MODULE JSRL [AND RETURN]
;
;CALCULATE QUADRANT (X,Y),(-X,Y),(X,-Y) MODULES
;
10$:	LDX	I,4		;ASSUME -X
	LDY	I,4		;  "    -Y
	DEC	DELX+1		;FOR FLAME
	DEC	DELY+1
	CMP	I,10
	BCC	20$
	CMP	I,25.
	BCC	15$
	LDX	I,0
	INC	DELY+1		;SET FOR FLAME
	BEQ	25$		;ALWAYS
15$:	AND	I,0F		;SHIPS 16 TO 24
	BPL	30$		;ALWAYS
20$:	LDY	I,0
	INC	DELX+1		;SET FOR FLAME
25$:	JSR	COMP		;SHIPS 9 TO 15
	AND	I,7
30$:	STX	DELX
	STY	DELY
	JSR	M.OFFS		;GET ADDRESS OF PROPER MODULE JSRL
	STY	TEMP1		;TEMP1 = LO BYTE OF ADDRESS
	STA	TEMP1+1		;TEMP1>>JSRL TO MODULE
	LDY	I,0		;CONVERT JSRL TO ABSOLUTE ADDRESS
	LDA	NY,TEMP1
	STA	TEMP3
	INY
	LDA	NY,TEMP1
	AND	I,0F
	ORA	I,20
	ASL	TEMP3
	ROL
	STA	TEMP3+1		;TEMP3 = ADDRESS OF MODULE VCTRS
	BIT	LUNARNUM
	BVC	40$		;LARGE MODULE
	LDA	TEMP3		;TEMP3 = ADDRESS OF SMALL MODULE'S VCTRS
	CLC			;FOR ADD
	BCC	41$		;ALWAYS
40$:	LDY	I,0
	LDA	NY,TEMP3
	STA	RAMLD		;RAMLD=GLOBE JSRL
	INY
	LDA	NY,TEMP3
	AND	I,0F
	ORA	I,20
	STA	RAMLD+1
	ASL	RAMLD
	ROL	RAMLD+1
	JSR	SHPINV		;INVERT GLOBE
	LDA	TEMP3
	CLC
	ADC	I,2
41$:	STA	RAMLD
	LDA	TEMP3+1
	ADC	I,0
	STA	RAMLD+1		;RAMLD=REST OF SHIP ADDR
				;CONTINUE TO SHPINV
;
;POINTR=VG INSTRUCTION LIST
;RAMPTR=CODE DESTINATION
;ALL REG'S USED
SHPINV:	LDY	I,0
SHPLP:	LDA	NY,RAMLD		;1ST BYTE OF INSTR
	STA	NY,RAMPTR
	INY
	LDA	NY,RAMLD
	CMP	I,0A0
	BCC	SHPVEC		;VECTOR INSTRUCTION
	CMP	I,0F0
	BCS	SHPALP		;ALPHA-NUMERIC
	DEY
	JMP	TRNINC		;FINISHED W/VG INSTRUCTIONS
				;UPDATE RAMPTR TO NEXT AVAIL LOCATION
SHPVEC:	EOR	DELY		;-(Y SIGN)
	STA	NY,RAMPTR
	INY
	LDA	NY,RAMLD
	STA	NY,RAMPTR
	INY
	LDA	NY,RAMLD
	EOR	DELX		;-(X SIGN)
	STA	NY,RAMPTR
	INY
	BNE	SHPLP		;ALWAYS BRANCH
SHPALP:	EOR	DELY		;-(Y SIGN)
	STA	NY,RAMPTR
	DEY
	LDA	NY,RAMPTR
	EOR	DELX		;-(X SIGN)
	STA	NY,RAMPTR
	INY
	INY
	BNE	SHPLP		;ALWAYS BRANCH
;
;	ENTRY ACC = 2 * SHIP # (A,Y REGS USED AND BLITZED)
;	@ EXIT ACC,Y = ADDRESS OF JSRL TO MODULE (LITTLE OR LARGE)
;
M.OFFS:	ASL			;ACC = 2*SHIP #
	STA	OFFSET		;SAVE FOR FLAME
				;CARRY IS CLR
	BIT	LUNARNUM	;CHECK SCAPE
	BVC	10$		;BRANCH - MINOR SCAPE
	ADC	I,LTLMOD&0FF	;ELSE - MAJOR - LITTLE MODULES
	TAY			;Y = LO BYTE OF ADDRESS
	LDA	I,LTLMOD/100
	BNE	20$		;ALWAYS
10$:	ADC	I,SHIPS&0FF	;MINOR - LARGE MODULES
	TAY
	LDA	I,SHIPS/100
20$:	ADC	I,0		;ACC = HI BYTE OF ADDRESS
	RTS
;
;CONVERT SHIP LOCATION FORMAT TO LABS (VG) FORMAT [XCURR,YCURR]
;
POSTMOD:LDA	XCURADJ+1
	LDX	XCURADJ
	JSR	ROTATE
	STA	XCURR+1
	STY	XCURR
	LDA	YCURADJ+1
	LDX	YCURADJ
	JSR	ROTATE
	STY	YCURR
	ORA	I,0A0
	STA	YCURR+1
	RTS
;
;FLAME - ADD FLAME TO SHIP
;
;ENTRY	(THRUST) = THRUST VALUE (0-F)
;	(SHIP) = SHIP ROTATION (0-1F)
;	(VGLIST,VGLIST) = WHERE TO GENERATE VECTORS FOR FLAME
;EXIT	(VGLIST,VGLIST) = NEW VECTOR LIST POINTER
;USES	A,X,Y,(XCOMP,XCOMP+3),(TEMP1,TEMP2),(TEMP3,TEMP4)
FLAME:	LDA	THRUST
	BNE	1$		;CALCULATE FLAME IF THRUST <> 0
	RTS
				;OFFSET, DELX+1, &DELY+1 SET IN MODULE
1$:	LDX	OFFSET		;X=2*ROTATION
	LDY	AX,FLAMEA+1
	LDA	AX,FLAMEA
	BIT	LUNARNUM
	BVC	6$
	LDY	AX,FLAMEB+1	;SMALL FLAME
	LDA	AX,FLAMEB	;FOR MAJOR
6$:	BIT	DELX+1
	BPL	7$
	JSR	COMP
7$:	STA	DELX
	TYA
	BIT	DELY+1
	BPL	8$
	JSR	COMP
8$:	STA	DELY
	LDA	THRUST
	LDY	I,FLMFRC
	JSR	MULTPA
	TAY
	LDA	FRAME
	LSR
	BCC	9$		;VARY FLAME EVERY OTHER FRAME
	INY			;Y=THRUST/4+1(1-4)
9$:	LDA	THRUST
	LSR
	CLC
	ADC	I,8
	ASL
	ASL
	ASL
	ASL
	BCC	10$
	LDA	I,0F0		;ABORT FLAME INTENSITY
10$:	STA	VGBRIT		;SET BRIGHTNESS
	STY	TEMP3		;TEMP3=THRUST'
	TYA
	LDY	DELY
	JSR	MULTPA		;Y*A
	STX	TEMP4		;TEMP4=DELY*THRUST'
	LDA	DELX
	JSR	COMP
	TAY
	LDA	TEMP3
	JSR	MULTPA
	STX	TEMP3		;TEMP3=-DELX*THRUST'
	LDA	DELX+1
	EOR	DELY+1
	BPL	20$
	JSR	FLAMEM		;MINUS FLAME SIDE
	JMP	FLAMEP		;PLUS FLAME SIDE
20$:	JSR	FLAMEP
	JMP	FLAMEM
;
FLAMEP:	LDY	I,0
	LDA	TEMP4
	CLC
	ADC	DELX
	BPL	10$
	DEY			;EXTEND SIGN
10$:	STA	XCOMP
	STY	XCOMP+1		;X=DELY*THRUST'+DELX
	LDX	I,0
	LDA	TEMP3
	CLC
	ADC	DELY
	BPL	20$
	DEX			;EXTEND SIGN
20$:	STA	XCOMP+2		;Y=(-DELX*THRUST')+DELY
	STX	XCOMP+3
	JMP	FLMINV
;
FLAMEM:	LDA	TEMP4
	JSR	COMP
	LDX	I,0
	CLC
	ADC	DELX
	BPL	10$
	DEX			;EXTEND SIGN
10$:	STA	XCOMP		;X=-(DELY+THRUST')+DELX
	STX	XCOMP+1
	LDA	TEMP3
	JSR	COMP
	LDX	I,0
	CLC
	ADC	DELY
	BPL	20$
	DEX			;EXTEND SIGN
20$:	STA	XCOMP+2		;Y=(DELX*THRUST')+DELY
	STX	XCOMP+3
				;CONTINUE TO FLMINV
;
FLMINV:	LDA	DELX+1
	EOR	DELY+1
	BPL	10$		;NO INVERT
	LDA	XCOMP
	BEQ	5$
	JSR	COMP		;INVERT X
	STA	XCOMP
	LDA	XCOMP+1
	EOR	I,0FF
	STA	XCOMP+1
5$:	LDA	XCOMP+2		;INVERT Y
	BEQ	10$
	JSR	COMP
	STA	XCOMP+2
	LDA	XCOMP+3
	EOR	I,0FF
	STA	XCOMP+3
10$:	JMP	VGVCTR		;COMPUTE & STORE VCTR
;
FLAMEA:	.BYTE 0,-7		;(X,Y) COMPONENTS FOR BASE OF MODULE
	.BYTE 2,-6
	.BYTE 3,-6
	.BYTE 4,-5
	.BYTE 5,-5
	.BYTE 6,-4
	.BYTE 6,-3
	.BYTE 7,-2
	.BYTE 7,0		;...[SHIP 8]
;
FLAMEB:	.BYTE 0,-4		;(X,Y) COMPONENTS FOR SMALL
	.BYTE 1,-4		;MODULES
	.BYTE 1,-4
	.BYTE 2,-3
	.BYTE 3,-3
	.BYTE 3,-2
	.BYTE 4,-1
	.BYTE 4,-1
	.BYTE 4,0		;...[SHIP 8]

;
;
;
MESDATA:LDY	I,DATAVG&0FF
	LDA	I,DATAVG/100
	JSR	LODRM8		;TRANSFER 8 BYTES
	LDA	I,SCORE
				;LEAVE LEADING ZEROS
	JSR	D.LD4A		;DISPLAY SCORE VALUE
	LDY	I,1
	LDA	I,GMTIME+1
	CLC
	JSR	DIGITS		;DISPLAY MINUTES
	LDX	I,2
	JSR	LDRAM		;DISPLAY ':'
	LDY	I,1
	LDA	I,GMTIME
	JSR	D.LD4		;DISPLAY SECONDS
				;VCTR FOR FUEL
	LDA	I,FUEL+1
	JSR	D.LD4A		;DISPLAY FUEL VALUE
	LDA	I,ALTITD
	JSR	D.SIX		;DISPLAY ALTITUDE VALUE
				;VCTR FOR X VELOCITY
	JSR	LDRAM4
	LDA	I,VELOCX
	JSR	D.SIX		;DISPLAY X VELOCITY VALUE
	JSR	LDRAM4
	LDA	I,VELOCY
	JSR	D.SIX		;DISPLAY Y VELOCITY VALUE
;
	LDA	I,STARRW/100	;LOAD LABS FOR VELOCITY ARROWS
	LDY	I,STARRW&0FF
	JSR	LODRM8
	LDA	ARRWY		;LOAD Y VELOCITY ARROW
	ASL			;CARRY IS CLR
	ADC	I,YARROW&0FF	;GET Y VELOCITY ARROW
	JSR	DIRARW
	LDA	ARRWX		;LOAD X VELOCITY ARROW
	ASL			;CARRY IS CLR
	ADC	I,XARROW&0FF	;GET X VELOCITY ARROW
				;CONTINUE TO DIRARW
DIRARW:	TAY			;TOP BYTE = YARROW/100
	LDA	I,XARROW/100
	ADC	I,0
	JMP	LODRM2		;LOAD JSRL (ALPH)

D.LD4A:	LDY	I,2		;4 DIGITS
D.LD4:	CLC			;NO ZERO SURPRESS
	JSR	DIGITS		;DISPLAY DIGITS
	JMP	LDRAM4		;LOAD OFFSET VCTR

D.SIX:	LDY	I,3		;6 DIGITS
	JMP	DIGTYS		;DISPLAY DIGITS

COMP:	EOR I,0FF		;2'S COMP ACC.
	CLC
	ADC I,01
COMP1:	RTS
;
;LANDING SITES [DONE BY OVERLAY ON VECTOR]
;	TABLE OF SITES [TABSIT)
SITES:	LDX	I,3
SITELP:	STX	EXP		;DISPLAY BONUS SITES
	LDA	ZX,TABSIT
	STA	TEMP1		;TEMP1 = SITE #
	ASL
	ASL
	STA	OFFSET
	LDX	I,TBLABS/100	;ASSUME MAJOR
	LDA	I,TBLABS&0FF
	LDY	I,3
	BIT	LUNARNUM
	BVS	10$		;BRANCH - MAJOR
	LDX	I,TBMNA/100
	LDA	I,TBMNA&0FF
	LDY	I,0F
10$:	STY	DELX+1		;SET QUADRANT WRAP AROUND
	JSR	SITADD		;LOAD A,Y WITH SITE LABS ADDR
	LDX	LUNAROT
	STX	DELX
	JSR	SCRLD1		;LABS & WAIT
	LDA	RAMPTR		;SAVE RAMPTR IN CASE OF BLANKING SITE
	STA	POINTR
	LDA	RAMPTR+1
	STA	POINTR+1
	LDX	TEMP1		;OFFSET FOR SITE VCTRS
	LDA	AX,MNVAL
	STA	OFFSET
	LDX	I,TBVCTR/100	;ASSUME MAJOR
	LDA	I,TBVCTR&0FF
	BIT	LUNARNUM
	BVS	20$		;BRANCH - MAJOR
	LDX	I,TBMNV/100
	LDA	I,TBMNV&0FF
20$:	JSR	SITADD		;A,Y = SITE VCTR ADDR
	JSR	LODRM8		;LOAD SITE VCTR (8 BYTES)
	LDA	FRAME
	AND	I,10
	BNE	30$
				;MAKE LANDING SITE VCTR ZERO INTENSITY
	LDY	I,3		;TOP NIBBLE OF THIRD BYTE = VCTR INTENSITY
	LDA	NY,POINTR
	AND 	I,0F
	STA	NY,POINTR
	BPL	40$		;ALWAYS
30$:	LDA	I,B.XOFF/100	;OFFSET TO CENTER '#X'
	LDY	I,B.XOFF&0FF
	JSR	LODRM2
	LDX	TEMP1
	LDA	AX,TBSTFT	;A = BONUS FACTOR FOR LAND SITE
	ASL
				;CARRY IS CLEAR
	ADC	I,VGMSGA+2&0FF	;DISPLAY BONUS FACTOR BY SITE
	TAY
	LDA	I,VGMSGA+2/100
	ADC	I,0
	JSR	LODRM2		;LOAD JSRL TO FACTOR (NUMBER)
	LDA	I,24.		;DISPLAY 'X'
	JSR	MESSRG
40$:	LDX	EXP
	DEX
	BPL	SITELP
	RTS			;FINISHED
;
SITADD:	CLC
	ADC	OFFSET		;ADD TABLE OFFSET
	TAY
	TXA
	ADC	I,0
	RTS
;
;	RTP MESSAGES
;
DSPRTP:	JSR	BMNBLK
	LDX	I,0
	LDA	I,22.
	JSR	MESSAGE		;DISPLAY 'SELECT OPTION'
	LDX	I,28.
	LDA	I,0
	JSR	MESSAGE		;DISPLAY 'PUSH START'
	LDX	I,32.
	JSR	MESSLAB		;LOAD LABS & WAIT
	LDA	I,FUEL+1	;DISPLAY FUEL PRESENT
	JSR	DIGT2S
	LDA	I,23.		;DISPLAY 'FUEL UNITS'
	JMP	MESSRG
B.XOFF:	.WORD	0F007		;BONUS SITE '#X' OFFSET (-6,0,0)
;
;	STATUS DISPLAYS MESSAGES ABOUT CONDITION OF FUEL
;		A) OUT OF FUEL, B)LOW ON FUEL
;		C) LOSS OF FUEL [BY EXIT FROM MAJOR]
;	ALL REG'S USED, POINTR, POINTR+1, MSCNT1
;	CALLS LOADRAM, DSPLAY, DIGITS, DSPLAA ROUTINES
;
STATUS:	LDA	MSCNT1		;DISPLAY "LOSS FUEL" MESSAGE
	BEQ	10$		;FOR MSCNT1 COUNTS
	DEC	MSCNT1
	LDX	I,8
	JSR	MESSLAB		;LOAD LABS & WAIT
	LDA	I,FLDED		;DISPLAY QUANTITY OF FUEL LOST
	JSR	DIGT2S
	JMP	MESSFU		;DISPLAY "FUEL UNITS LOST"
10$:	LDX	I,4
	LDA	I,2		;CHK OUT OF FUEL
	LDY	I,0		;ASSUME NO SOUND (FOR LOW ON FUEL)
	BIT	CRDTFLG
	BPL	20$		;BRANCH - OUT OF FUEL
	LDA	FUEL+2		;CHK LOW ON FUEL (<100 UNITS)
	BNE	25$		;BRANCH - NOT YET
	LDA	FRAME
	AND	I,10		;FLASH 'LOW ON FUEL'
	BNE	25$
	LDA	I,1		;DISPLAY 'LOW ON FUEL'
	LDY	I,10		;MAKE LOW ON FUEL SOUND
20$:	STY	TEMP1		;SAVE SOUND STATUS
	JSR	MESSAGE		;DISPLAY LIST
	LDY	TEMP1		;RETRIEVE SOUND STATUS
25$:	TYA
	TAX			;X = SOUND BIT STATE (FOR LOW ON FUEL)
	LDA	I,2F		;CLR LOW SOUND (SLAM & THRUST)
	JMP	S.SND
;
;DISPLAY CRASH/LAND MESSAGES
;	ALL REG'S USED
;	ADDS ALPHA JSRL'S TO VGRAM
;MESSAGE, DIGITS ROUTINES USED
;
DSPMOT:	LDA	MSCNT1		;DISPLAY MESSAGE WHILE MSCNT1 <> 0
	BEQ	10$		;(FUEL LOSS MESSAGE)
	DEC	MSCNT1
	LDX	I,16.		;LABS 332,640
	LDA	I,6		;AUX. FUEL TANKS
	JSR	MESSAGE
	LDX	I,8		;LABS 392,600
	JSR	MESSLAB		;LOAD VG RAM W/ LABS
	LDA	I,FLDED		;FLDED = 2 BYTES DECIMAL FUEL LOST
	JSR	DIGT2S		;DISPLAY FUEL LOST
	JSR	MESSFU		;DISPLAY 'FUEL UNITS LOST'
10$:	LDX	I,24.		;LABS (446,432)
	JSR	MESSLAB		;LOAD RAM W/LABS,WAIT
	LDA	I,NUMB1		;NUMB1 = 2 BYTES HEAT SCORE
	JSR	DIGT2S		;DISPLAY HEAT SCORE POINTS
	LDA	I,21.		;DISPLAY ' POINTS'
	JSR	MESSRG		;LOAD RAM WITH ALPHA JSRL'S
	LDA	M.CLFL		;CHECK LANDING STATUS
	AND	I,0F
	BNE	40$		;BRANCH - CRASH
	LDX	I,20.		;GOOD/HARD LABS
	LDA	I,7		;ASSUME GOOD LANDING
	BIT	M.CLFL
	BVC	30$		;BRANCH - GOOD
	LDA	I,8		;HARD LANDING MESSAGE
	JSR	MESSAGE		;LOAD LABS, WAIT & MESSAGE
	LDX	I,44.		;HARD LANDING STATUS LABS
	LDA	I,13.		;ADD HARD MESSAGE OFFSET
	BNE	35$		;ALWAYS
30$:	JSR	MESSAGE		;LOAD LABS & JSRL'S
	LDX	I,40.		;GOOD LANDING STATUS LABS
	LDA	I,9		;ADD GOOD MESSAGE OFFSET
35$:	CLC
	ADC	RNDOM		;PLUS RANDOM # (0 1 2 3)
	JMP	MESSAGE		;ADD LABS, WAIT, & MESSAGE STRING
40$:	LDX	I,36.		;CRASH STATUS LABS
	LDA	I,17.		;CRASH MESSAGE OFFSET
	BNE	35$		;ALWAYS
;
ENGMSG:	.WORD	PUSH		;PRESS START ... (#0)
	.WORD	LOW		;LOW ON FUEL
	.WORD	OUT		;OUT OF  "
	.WORD	LOSS		;FUEL UNITS LOST
	.WORD	COIN		;INSERT COINS	(#4)
	.WORD	MONFUEL		;FUEL UNITS/COIN
	.WORD	DEST		;AUX. FUEL TANKS ...
	.WORD	CONG		;CONG ...	
	.WORD	SATIRE		;YOU ... HARD	(#8)
	.WORD	GOOD0		;GOOD LANDING
	.WORD	GOOD1
	.WORD	GOOD2
	.WORD	GOOD3		;		(#12)
	.WORD	HARD0		;HARD LANDING
	.WORD	HARD1
	.WORD	HARD2
	.WORD	HARD3		;		(#16)
	.WORD	BAD0		;CRASH
	.WORD	BAD1
	.WORD	BAD2
	.WORD	BAD3		;		(#20)
	.WORD	HTPNTS		;POINTS
	.WORD	SELECT		;SELECT OPTION
	.WORD	FUELCT		;FUEL UNITS CREDIT
	.WORD	XSCORE		; X SCORE	(#24)
	.WORD	MON0		;C. OPTION 1
	.WORD	MON1		;"    "    2
	.WORD	MON2		;"    "    3	
	.WORD	MON3		;"    "    4	(#28)
;
;ENGLISH MOTION MESSAGE'S OFFSETS
;
E.MOFF:	.BYTE 0,24.,6.,54.	;GOOD
	.BYTE 60.,60.,18.,0	;HARD
	.BYTE 186.,60.,0,102.	;BAD
;
;	ASCVG MESSAGE STRINGS
;
LOW:	.ASCVG	<LOW ON FUEL>
OUT:	.ASCVG	<OUT OF FUEL>
LOSS:	.ASCVG	<LOST>
FUELCT:	.ASCVG	< FUEL UNITS >
COIN:	.ASCVG	<INSERT COINS>
PUSH:	.ASCVG	<PUSH START>
SELECT:	.ASCVG	<SELECT OPTION>
HTPNTS:	.ASCVG	< POINTS>
MON0:	.ASCVG	<450>
MON1:	.ASCVG	<600>
MON2:	.ASCVG	<750>
MON3:	.ASCVG	<900>
MONFUEL:.ASCVG	<PER COIN>
XSCORE:	.ASCVG	<X>
DEST:	.ASCVG	<AUXILIARY FUEL TANKS DESTROYED>
CONG:	.ASCVG	<CONGRATULATIONS>
SATIRE:	.ASCVG	<YOU LANDED HARD>
;
GOOD0:	.ASCVG	<THAT WAS A GREAT LANDING>
GOOD1:	.ASCVG	<THE EAGLE HAS LANDED>
GOOD2:	.ASCVG	<THE COLUMBIA HAS LANDED>
GOOD3:	.ASCVG	<YOU HAVE LANDED>
;
HARD0:	.ASCVG	<LIFE SUPPORT IS GONE>
HARD1:	.ASCVG	<YOUR TRIP IS ONE WAY>
HARD2:	.ASCVG	<YOU ARE HOPELESSLY MAROONED>
HARD3:	.ASCVG	<COMMUNICATION SYSTEM DESTROYED>
;
BAD0=	HARD3+15				;DESTROYED
BAD1:	.ASCVG	<YOU CREATED A TWO MILE CRATER>
BAD2:	.ASCVG	<YOU JUST DESTROYED A 100 MEGABUCK LANDER>	;MEG-A-WHO???
BAD3:	.ASCVG	<THERE WERE NO SURVIVORS>
;
;
	.SBTTL	CHKSUM #8 (6800 - 6BFF)  [18]
	.BYTE	0
	.PAGE
	.SBTTL	FRACTIONAL MULTIPLY
;
;FRACTIONS ARE ENCODED AS BIT7=1/2, BIT6=1/4....
;	A 1 SIGNIFIES ADDITION
;FRACTIONAL MULTIPLICATION [X&Y THRUST COMPONENTS]
;
FRCMLT:	LDA	SHIP
	LSR
	LSR
	LSR			;ACC = SHIP QUADRANT ROTATION (0 - 3)
	TAX			;X = QUADRANT
	LDA	AX,SIGNS	;GET XY THRUST SIGNS FOR QUADRANT
	STA	SGNTRX		;X THRUST SIGN (D7)
	ASL
	STA	SGNTRY		;Y THRUST SIGN (D7)
	LDX	THRUST		;1 OUT OF 16 THRUST
	LDA	AX,TRSTAB
	STA	THRSTLV
	LDA	SHIP		;ACC = SHIP #
	AND	I,0F
	CMP	I,9
	BCC	10$
	EOR	I,0F		;2'S COMP.
	ADC	I,0		;ADD ONE (CARRY IS SET)
10$:	STA	TEMP1		;TEMP1 = Y THRUST SINE TABLE OFFSET
	EOR	I,7
	ADC	I,1		;X = X THRUST SINE TABLE OFFSET
				;ADD 1 (CARRY IS CLR)
	AND	I,0F
	TAX			;X = 1 OUT OF 8 OFFSET
	LDA	AX,SINES
	LDY	THRSTLV		;Y = SHIP THRUST LEVEL (AMOUNT)
	JSR	MULTPA		;COMPUTE X THRUST
	STA	XTHRUST
	LDX	TEMP1
	LDA	AX,SINES
	JSR	MULTPA		;COMPUTE Y THRUST (Y REG UNTOUCHED)
	STA	YTHRUST
	RTS
;
;
;
BURN:	LDA	I,FUELFAC	;FUEL USED=THRUST LEVEL*FUEL FACTOR
	LDY	THRSTLV	
	BMI	10$		;ABORT FUEL LEVEL
	LDX 	PLYMOD
	CPX	I,2
	BNE	10$
	LDA	I,FLFAC2	;PLAY TYPE #2 (PRIME)
10$:	JSR	MULTPA
	TAX
	LDY	I,0
	STY	TEMP1
	LDY	I,7			;CNVRT ONE BYTE (IN X) TO DECIMAL
	JSR	DECCNV
	TAY
	JMP	GASA			;SUBTRACT FUEL (X.Y)
;
;DEDUCT CALCULATES LOSS OF FUEL DUE TO CRASH OR RESET
;	ALL REG'S USED, TEMP1,TEMP1+1,TEMP3,TEMP4,TEMP5
;	@ EXIT FUEL HAS BEEN UPDATED
;		MSCNT1	= DISPLAY COUNT FOR FUEL LOSS MESSAGE
;		FLUSE,FLUSE+1	= FUEL LOST
;
DEDUCT:	LDA	COLFLG
	AND	I,0F
	BEQ	DEDSET		;INITIALIZE (NO DEDUCT ON LANDING)
DEDCTA:	SED
	LDA	FLMIN		;FLMIN=MIN. FUEL THAT SHOULD BE USED
	SEC
	SBC	FLUSE+1		;FLUSE=FUEL USED BY PLAYER
	TAX
	LDA	FLMIN+1
	SBC	FLUSE+2
	TAY
	LDA	FLMIN+2
	SBC	I,0
	CLD
	BCC	DEDSET		;MORE THAN MIN. FUEL USED
	BEQ	20$
	LDX	I,99		;MAX FUEL LOST
	LDY	I,99
20$:	TXA			;CHECK LOWER BYTE
	BNE	25$
	TYA			;CHECK UPPER BYTE
	BEQ	DEDSET		;BRANCH IF BOTH ARE 0 (MIN FUEL USED)
25$:	TYA
	LDY	FUEL+1
	STY	TEMP4
	LDY	FUEL+2
	STY	TEMP5
	LDY	I,0
	STY	FLUSE+1		;CLR FLUSE (WILL BE SET IN GAS)
	STY	FLUSE+2
	JSR	GAS		;SUBTRACT FUEL LOST/DESTROYED
	LDA	FLUSE+1
	LDX	FLUSE+2
	BIT	CRDTFLG
	BMI	30$
	LDA	TEMP4
	LDX	TEMP5
30$:	STA	FLDED		;FLDED=FUEL LOST
	STX	FLDED+1
	ORA	FLDED+1
	BEQ	DEDSET		;LOST FUEL=0
	LDA	I,DEDCNT
	STA	MSCNT1		;SET DISPLAY COUNTER
DEDSET:	RTS
;
;CHECKS FOR LANDING ON A CHOSEN SITE
;
LNDADR:	LDA	XCURR
	CLC
	ADC	SCROLL+1
	STA	TEMP1
	LDA	XCURR+1
	ADC	LUNAROT
	AND	I,0F
	TAY			;Y, TEMP1=LANDING SITE
	LDX	I,MAXSITE-1
LNDLP:	STX	EXP
	LDA	ZX,TABSIT
	STA	TEMP4		;TEMP4 = SITE #
	ASL
	ASL
	TAX
	SEC
	LDA	TEMP1
	SBC	AX,TBMNA+2	;CHECK LANDING >= SITE LOCATION
	STA	TEMP2		;SAVE LOWER BYTE
	TYA
	SBC	AX,TBMNA+3
	BCC	10$		;LANDING < SITE
	BNE	10$		;ANY SITE < 256.
	LDX	TEMP4		;CHECK FOR GOOD LANDING
	LDA	AX,MNVAL
	LSR
	LSR
	LSR			;LOWER THREE BITS SPECIFY SITE
	TAX
	LDA	AX,TSTLNG	;COMPARE SITE LENGTH WITH SHIP POSITION
	CMP	TEMP2
	BCS	LNDGD		;SUCCESSFUL SITE LANDING
10$:	LDX	EXP
	DEX
	BPL	LNDLP		;CHK NEXT SITE
	LDA	I,1		;DEFAULT IS NORMAL POINTS
	BNE	LNPNTS		;ALWAYS BRANCH
LNDGD:	LDX	TEMP4		;SITE #=SCORE TABLE OFFSET
	LDA	AX,TBSTFT	;GET BONUS FACTOR
LNPNTS:	TAY			;Y=FACTOR
	STA	BNFACT
10$:	JSR	POINTS		;REPEAT SCORE FOR BONUS SITE TIMES (DEFAULT IS 1)
	DEY
	BNE	10$
	SED			;DECIMAL MODE FOR SCORE
	STX	NUMB1		;NUMB1 = LANDING SCORE (NORMAL)
	STY	NUMB2		;NUMB2 = TOP BYTE OF SCORE (Y=0)
	TYA
20$:	CLC
	ADC	NUMB1		;ADD SCORE FOR BONUS FACTOR
	BCC	30$
	INC	NUMB2		;ADD IN CARRY (HUNDREDS DIGIT <3)
30$:	DEC	BNFACT		;DELX = BONUS LANDING FACTOR (1 TO 5)
	BNE	20$		;REPEAT ADD
	STA	NUMB1		;STORE LOWER TWO DIGITS
	CLD
	RTS			;FINISHED
;
TBSTFT:	.BYTE	2,2,2,2,3,3,4,4,4,4,5,5,5,5,5
MNVAL:	.BYTE	0,8,16.,16.,24.,16.,24.,24.,24.,24.,24.,24.,24.,24.,24.
TSTLNG:	.BYTE	0FF,80,40,20	;SITE LENGTHS
;
	MAXSITE=4		;4 SITES ALLOWED
;
;
	.SBTTL	CHKSUM #9 (6C00 - 6FFF)  [14]
	.BYTE	0

	.SBTTL	ACCELERATION
;
;ACCELERATION ROUTINE
;	UPDATES MODULE X,Y POSITION & VELOCITIES
;Y ACCELERATION = GRAVITY + Y THRUST COMPONENT
;X ACCELERATION = X THRUST COMPONENT
;
;
;
ACCEL:	LDX	I,2		;DO Y ACCEL FIRST
ACLOOP:	STX	TEMP1		;SAVE VARIABLE OFFSET
	LDA	I,0
	STA	COLFLG		;INITIALLY NO COLLISION (EACH FRAME)
	STA	SDESSGN
	STA	SUMSOR+1
	LDA	ZX,MJRFLG	;CHECK FOR SCAPE SCROLLING
	BMI	ACPRE		;BRANCH - SCAPE SCROLLING
	LDA	ZX,VELX+1
	STA	SUMSOR		;HIGH BYTE OF VELOCITY
	LDA	ZX,VELX		;LOW BYTE  "     "
	BIT	LUNARNUM	;WHICH SCAPE DISPLAYED ?
	BVS	ACPOS		;BRANCH - MAJOR
	ASL			;FOR MINOR VEL = 4.0 * VEL
	ROL	SUMSOR
	ROL	SUMSOR+1
	ASL
	ROL	SUMSOR
	ROL	SUMSOR+1
ACPOS:	LDA	ZX,SGNVLX
	STA	SSORSGN		;VEL SIGN (BIT 7)
	LDA	ZX,XCURADJ+1	;HIGH BYTE OF SHIP ADJUSTED POSITION
	PHA			;SAVE
	LDA	ZX,XCURADJ	;LOW BYTE OF SHIP ADJUSTED POSITION
	TAX			;X = LOW BYTE
	PLA			;RESTORE HIGH BYTE
	JSR	SUMSB		;ADJUST POSITION BY VELOCITY
	LDX	TEMP1		;X = VAR OFFSET
	STA	ZX,XCURADJ+1	;STORE NEW ADJUSTED POSITION
	STY	ZX,XCURADJ
ACPRE:	LDA	I,0
	STA	SUMSOR+1
	TXA			;X = 0 (VELX)
	BEQ	10$		;BRANCH - X GRAVITY = 0
	LDA	GRAVITY
10$:	STA	SUMSOR
	LDA	I,80
	STA	SSORSGN		;GRAVITY SUBTRACTED (ALWAYS)
	LDY	ZX,SGNVLX	;VEL SIGN
	LDA	ZX,VELX+1	;TOP BYTE OF VELOCITY
	PHA			;SAVE IT
	LDA	ZX,VELX		;LOW BYTE OF VELOCITY
				;X ALREADY SAVED IN TEMP1
	TAX			;X = LOW VELOCITY BYTE
	PLA			;ACC = HIGH BYTE
	JSR	SUMSA		;VEL = VEL - GRAVITY
	LDA	TEMP1
	LSR			;DIVIDE BY 2 (= 1 OR 0)
	TAX			;X = 1 (VELY) OR 0 (VELX)
	LDA	ZX,XTHRUST
	STA	SUMSOR		;THRUST VALUE ALONG AXIS
	LDA	ZX,SGNTRX	;SIGN OF THRUST
	STA	SSORSGN		;VEL = VEL + THRUST
	LDA	PLYMOD		;CHECK GAME VERSION
	CMP	I,2
	BNE	20$		;BRANCH - NOT VERSION TWO
	LDA	SUMSOR		;VERSION 2 - 1.5 * THRUSTS
	LSR
	CLC
	ADC	SUMSOR
	STA	SUMSOR
	BCC	20$
	INC	SUMSOR+1	;ADD IN CARRY
20$:	JSR	SUMSUM		;ADD THRUSTS TO VELOCITIES
	PHA			;SAVE TOP BYTE
	TXA			;ACC = SIGN OF VELOCITY
	LDX	TEMP1		;X = OFFSET
	STA	ZX,SGNVLX	;STORE SIGN
	STY	ZX,VELX		;STORE LOW BYTE OF VELOCITY
	PLA
	STA	ZX,VELX+1	;STORE HIGH BYTE OF VELOCITY
	DEX
	DEX
	BMI	30$		;BRANCH - FINISHED
	JMP	ACLOOP		;DO X VELOCITY & POSITION
30$:	RTS
;
;
;
ROTATE:	STX	SUMDES
	ASL	SUMDES
	ROL
	ROL	SUMDES
	ROL
	TAY
	LDA	SUMDES
	ROL
	AND	I,3
	RTS
;
;DETERMINES SUM OF TWO 2-BYTE FIELDS
;	USES - SUMSOR, SUMDES, SSORSGN, SDESSGN
; EXIT - A=SUMDES+1,Y=SUMDES,X=SDESSGN
SUMSA:	STY	SDESSGN
SUMSB:	STA	SUMDES+1
SUMSC:	STX	SUMDES
SUMSUM:
	LDA	SSORSGN
	EOR	SDESSGN
	BPL	40$
	SEC
	LDA	SUMDES
	SBC	SUMSOR
	TAY
	LDA	SUMDES+1
	SBC	SUMSOR+1
	BCC	30$		;SOURCE IS LARGER
	BNE	20$		;DEST IS LARGER
	CPY	I,0
	BNE	20$
10$:	STA	SUMDES		;EQUAL (A=0)
	STA	SUMDES+1
	STA	SDESSGN
	TAX
	TAY
	RTS			;FINISHED DEST=SOURCE
20$:	LDX	SDESSGN
25$:	STY	SUMDES		;DEST GREATER
	STA	SUMDES+1
	RTS
30$:	EOR	I,0FF		;SOURCE GREATER
	TAX			;SO 2'S COMPLEMENT RESULT
	TYA
	EOR	I,0FF
	TAY
	INY
	BNE	35$
	INX
35$:	TXA			;ACC,Y = MAGNITUDE BYTES
	LDX	SSORSGN		;X = SIGN
	STX	SDESSGN
	BCC	25$		;ALWAYS
40$:	CLC
	LDA	SUMDES
	ADC	SUMSOR
	TAY
	LDA	SUMDES+1
	ADC	SUMSOR+1
	BCC	20$
	LDA	I,0FF		;OVER/UNDER FLOW
	TAY
	BCS	20$		;ALWAYS
	.PAGE
	.SBTTL	LUNARSCAPE DECODE
;DECODE LUNARSCAPE VG INSTRUCTIONS
;ON EXIT - X,Y=CURRENT MODULE COOR; XPRE,YPRE=INSTR
;
DECODE:	JSR	POSTMOD		;RESET X,X+1,Y,& Y+1 VALUES
	LDA	I,STKSPCE&0FF	;INITIALIZE SOFTWARE
	STA	STACK		;  DECODE STACK POINTER
	LDX	I,STKSPCE/100
	STX	STACK+1
	LDA	FRAME
	LSR
	BCS	12$		;DECODE LEFT SIDE ON EVEN FRAMES
	STX	DISTFLG		;X = 0
	DEX			;X=0FF
	STX	DISTXL		;MAX DISTANCE
	STX	DISTXL+1
	STX	DISTYL
	STX	DISTYL+1
	LDY	I,SHPUPL&0FF
	LDX	I,SHPUPL/100
	BNE	13$		;ALWAYS
12$:	LDA	I,0C0		;DECODE RIGHT SIDE ON ODD FRAMES
	STA	DISTFLG
	DEX			;X = 0FF
	STX	DISTXR		;MAX DISTANCE
	STX	DISTXR+1
	STX	DISTYR
	STX	DISTYR+1
	LDY	I,SHPLWR&0FF
	LDX	I,SHPLWR/100
13$:	JSR	CNVRT		;CALCULATE CORNER (UPPER LEFT OR LOWER RIGHT)
	LDA	XPOLAN
	CLC
	ADC	SCROLL+1
	TAY
	LDA	XPOLAN+1
	AND	I,3
	ADC	I,0
	TAX
	TYA
	SEC
	SBC	I,30		;START AT EARLIER QUADRANT ON CARRY
	TAY			;SAVE LOWER BYTE IN Y
	TXA			; CHECK 30 BEFORE SHIP POSITION
	SBC	I,0
	BCS	15$
	LDY	I,0		;DEFAULT TO FULL QUAD IF RESULT < 0
	TYA			;SET QUAD = 0
15$:	BIT	LUNARNUM	;HALF QUADRANT ONLY IN MAJOR
	BVS	16$
	LDY	I,0		;CLR FOR MINOR
16$:	STY	TEMP2		;HALF QUADRANT VALUE
	STA	TEMP3		;SAVE QUADRANT TO BEGIN DECODE AT
	CLC
	ADC	LUNAROT
	BIT	LUNARNUM
	BVS	20$
	AND	I,0F		;MINOR LABS
	LDY	I,MINTBL&0FF
	LDX	I,MINTBL/100
	BNE	25$		;ALWAYS
20$:	AND	I,3		;MAJOR LABS
	STA	TEMP4
	LDY	I,LUNMJ0&0FF
	LDX	I,LUNMJ0/100
	BIT	TEMP2		;CHK HALF QUADRANT
	BPL	25$
	LDY	I,LNMJR&0FF	;DECODE FROM HALF QUADRANT [128.]
	LDX	I,LNMJR/100
25$:	STX	POINTR+1	;POINTR = TABLE ADDRESS OF SCAPE LABS FOR QUADRANTS
	STY	POINTR
	ASL
	ASL
	TAY
30$:	LDA	NY,POINTR	;LABS FOR SECTION
	SEC
	SBC	SCRADD+1
	STA	YPOS
	INY
	LDA	NY,POINTR
	AND	I,0F
	SBC	SCRADD+2
	STA	YPOS+1
	INY
	LDA	NY,POINTR
	SEC
	SBC	SCROLL+1
	STA	XPOS		;XPOS,YPOS = BEGINNING OF
	INY			;   SCREEN SEGMENT
	LDA	NY,POINTR
	AND	I,3		;SET PROPER QUADRANT
	SBC	I,0
	CLC
	ADC	TEMP3
	STA	XPOS+1
	LDA	TEMP3		;A = QUADRANT OF DECODE START
	TAX			;SAVE QUAD # IN X
	ASL
	CLC
	BIT	TEMP2		;CHK FOR HALF QUADRANT DECODE
	BPL	35$		;BRANCH - NOT HALF QUADRANT
	LDA	TEMP4		;ELSE - SAVE QUADRANT JSRL (RETURN ADDRESS) ON STACK
	ASL
	TAY
	LDA	AY,LNADMJR	;SET POINTR TO 1/2 POINT OF VG INSTR
	STA	POINTR		;FOR QUADRANT
	LDA	AY,LNADMJR+1
	STA	POINTR+1
	LDY	I,0
	INX
	TXA
	ASL
	ADC	RAMLUN		;CARRY IS CLR
	STA	NY,STACK	;SAVE RETURN ADDRESS (FOR QUADRANT JSRL)
	LDA	RAMLUN+1
	ADC	I,0
	INY
	STA	NY,STACK
	INC	STACK		;UPDATE STACK POINTER
	INC	STACK
	BNE	PRLOOP		;ALWAYS
35$:	ADC	RAMLUN		;POINTR = ADDR. OF
	STA	POINTR		;  SEGMENT JSRL (IN VG RAM)
	LDA	RAMLUN+1
	ADC	I,0
	STA	POINTR+1
PRLOOP:	LDY	I,0		;POINTR=POINTER INTO SCAPE VG LIST
LOOP:	LDA	NY,POINTR
	INY
	TAX			;X=BYTE OF VG INSTRUCTION
	LDA	NY,POINTR	;A=BYTE 1 OF VG INSTRUCTION
	INY
	CMP	I,0A0		;WHAT VG INSTRUCTION IS IT?
	BCC	DECVCTR		;DECODE VCTR INSTRUCTION
	CMP	I,0D0
	BCC	DECJSRL		;DECODE	JSRL
	BEQ	DECRTSL		;DECODE	RTSL
	JMP	DECALPH		;DECODE ALPH
DECRTSL:DEC	STACK
	LDY	I,0
	LDA	NY,STACK
	STA	POINTR+1	;GET POINTR FROM STACK
	DEC	STACK
	LDA	NY,STACK
	STA	POINTR
	JMP	LOOP
DECJSRL:STA	TEMP1
	TYA
	CLC
	ADC	POINTR
	LDY	I,0		;CLEAR STACK OFFSET
	STA	NY,STACK
	STX	POINTR
	INC	STACK
	LDA	POINTR+1
	ADC	I,0
	STA	NY,STACK
	INC	STACK
	LDA	TEMP1
DCJSRA:	AND	I,0F
	ORA	I,20
	ASL	POINTR
	ROL
	STA	POINTR+1
	BNE	PRLOOP		;DECODE NEXT INSTRUCTION
DECVCTR:STX	DELY		;DELY=LOWER BYTE OF DELTA Y
	TAX
	LDA	NY,POINTR	;ACC=LOWER BYTE OF DELTA X
	STA	DELX
	INY
	LDA	NY,POINTR
	INY
	STY	TEMP3		;TEMP3=POINTR OFFSET
	AND	I,3
	TAY			;Y=2 MSB'S OF DELTA X
				;DELTA X IS ALWAYS POSITIVE
	TXA
	AND	I,3
	STA	DELY+1		;DELY+1=2 MSB'S OF DELTA Y
	TXA
	ROR			;BIT 2=SIGN OF DELTA Y
	ROR
	ROR
	ROR
	STA	SSORSGN		;BIT 7=SIGN OF DELTA Y
	AND	I,0F
	STA	EXP		;EXP=VCTR OP-CODE
	LDA	I,9
	SEC
	SBC	EXP
	TAX			;EXP=VCTR TIMER
				; =# OF RIGHT SHIFTS TO GET
				;ABSOLUTE DELTA X & Y
	TYA			;A=2 MSB'S OF DELTA X
				;X = TIMER (AT LEAST ONE SHIFT NEEDED)
10$:	LSR			;RIGHT SHIFT DELTA X
	ROR	DELX
	LSR	DELY+1		;RIGHT SHIFT DELTA Y
	ROR	DELY
	DEX			;DECREMENT TIMER
	BNE	10$		;CONTINUE RIGHT SHIFTS
				;ABSOLUTE DELTA X IN ACC,DELX
				;ABSOLUTE DELTA Y IN DELY,DELY+1
DECVCA:	STA	DELX+1
	LDA	XPOS
	STA	XPRE		;NEW LEFT ENDPT=OLD RIGHT ENDPT
	CLC
	ADC	DELX
	STA	XPOS		;NEW RIGHT ENDPT=OLD RIGHT ENDPT+DELTA X
	LDA	XPOS+1		;CONSTRUCT NEW ENDPT(S) FOR
	STA	XPRE+1		;TOP BYTES
	ADC	DELX+1
	STA	XPOS+1
	BIT	SSORSGN		;CHK FOR NEGATIVE DELTA Y
	BPL	30$		;BRANCH-DELTA Y IS POSITIVE
	LDA	DELY		;ELSE- GET 2'S COMP DELTA Y
	EOR	I,0FF
	TAX
	LDA	DELY+1
	EOR	I,0FF
	TAY
	INX
	STX	DELY		;2'S COMP LOWER BYTE (DELY)
	BNE	25$
	INY			;ADD CARRY FROM LOWER BYTE
25$:	STY	DELY+1		;DELY+1,DELY=2'S COMP DELTA Y
30$:	LDA	YPOS		;NEW LEFT ENDPT=OLD RIGHT ENDPT
	STA	YPRE
	CLC
	ADC	DELY
	STA	YPOS		;NEW RIGHT ENDPT=OLD RIGHT+DELTA Y
	LDA	YPOS+1		;CONSTRUCT NEW ENDPT(S) FOR
	STA	YPRE+1		;TOP BYTES
	ADC	DELY+1
	STA	YPOS+1
				;CONTINUE TO DECCHK
DECCHK:				;CHECK FOR DISTANCE MEASUREMENT(S)
	LDA	XPOS+1		;CHECK FOR MAX X (=4) OR MIN X (MINUS)
	BPL	1$
	JMP	DECRET		;IF MINUS REPEAT DECODE UNTIL POSITIVE
1$:	BIT	DISTFLG		;CHECK IF -X (DISTXL) IS DONE
	BMI	DECPLY
	LDA	XPOS		;CHECK FOR DECODE BEYOND X OF SHIP CORNER
	CMP	XPOLAN
	LDA	XPOS+1
	SBC	XPOLAN+1
	BCC	5$		;BRANCH - NOT YET
	LDA	I,80		;DO LOWER LEFT CORNER OF MODULE
	STA	DISTFLG
	BCS	10$		;ALWAYS (CARRY SET)
5$:	LDA	YPOLAN		;CHECK FOR SEGMENT LOWER ENDPOINT
	CMP 	YPOS		;BEING BELOW SHIP CORNER
	LDA	YPOLAN+1
	SBC	YPOS+1
	BCC	DECRET		;WAIT FOR ENDPTS INTERSECTING YPOLAN
	LDA	I,80
	STA	DISTFLG
	LDA	YPRE		;CHECK FOR SEGMENT UPPER ENDPOINT
	CMP	YPOLAN		;BEING ABOVE SHIP CORNER
	LDA	YPRE+1
	BMI	10$		;IF NEGATIVE NO DISTANCE
	SBC	YPOLAN+1
	BCC	10$
	JSR	DSTNCX
	STA	DISTXL+1
	STY	DISTXL
	TXA			;X=SIGN OF RESULT
	BPL	10$
	LDA	I,8F
	STA	COLFLG
10$:	LDY	I,SHPLWL&0FF
	LDX	I,SHPLWL/100
	JSR	CNVRT		;XPOLAN TO YPOLAN+1 = SHIP LOWER
				;LEFT CORNER
DECPLY:	LDA	DISTFLG
	AND 	I,0F
	BNE	DECPLX
	LDA	XPOS		;XPOLAN TO YPOLAN+1 = SHIP LOWER
	CMP	XPOLAN		;CORNER
	LDA	XPOS+1
	SBC	XPOLAN+1
	BCC	DECRET
	JSR	DSTNCY
	BIT	DISTFLG
	BVS	10$
	STA	DISTYL+1
	STY	DISTYL
	JMP	DECOUT
10$:	STA	DISTYR+1	;SHIP LOWER RIGHT Y-AXIS
	STY	DISTYR		;DISTANCE
	LDX	I,0CF
	STX	DISTFLG
	LDY	I,SHPUPR&0FF
	LDX	I,SHPUPR/100	;XPOLAN TO YPOLAN+1 = SHIP
	JSR	CNVRT		;UPPER RIGHT CORNER
DECPLX:	LDA	XPOLAN		;EXIT ONCE DECODED 30 BEYOND
	CLC			;SHIP X POSITION
	ADC	I,30
	TAX
	LDA	XPOLAN+1
	ADC	I,0
	CPX	XPOS
	SBC	XPOS+1
	BCC	DECOUT
	LDA	YPOS
	CMP	YPOLAN
	LDA	YPOS+1
	BMI	DECRET		;WAIT FOR POSITIVE ENDPOINT
	SBC	YPOLAN+1
	BCC	DECRET
	JSR	DSTNCX
	STA	DISTXR+1	;SHIP UPPER RIGHT X-AXIS
	STY	DISTXR		;DISTANCE
	TXA			;X=SIGN OF RESULT
	BMI	DECOUT
	LDA	I,8F
	STA	COLFLG
DECOUT:	RTS			;FINISHED
DECRET:	LDY	TEMP3
	JMP	LOOP		;DECODE NEXT VG INSTR
DECALPH:STY	TEMP3
	STA	TEMP1		;TEMP1=BYTE 1 (OF ALPH)
	AND	I,3
	STA	DELY
	LDA	TEMP1
	AND	I,8
	LSR			;BIT D2 IN A=YAS
	STA	TEMP2
	TXA
	AND	I,8
	ORA	TEMP2		;D3=X AS; D2=YAS
	LSR
	LSR			;D1=XAS; D0=YAS
	STX	TEMP2		;TEMP2=BYTE 0 (OF ALPH)
	TAY
	TXA
	AND	I,3
10$:	ASL			;GET ABSOLUTE DELTA X(ACC) & DELTA Y(DELY)
	ASL	DELY
	DEY
	BPL	10$
	STA	DELX
	LDA	TEMP1		;BIT 3 =DELY SIGN
	LSR
	LSR
	ROR
	ROR			;D7 = SIGN OF DELY
	STA	SSORSGN
	LDA	I,0
	STA	DELY+1		;DELY TOP BYTE = 0
	JMP	DECVCA		;ADD DELX, DELY TO ENDPTS
;
;	TBLADDR,TBLADDR+1 = PROPER TABLE ADDRESS FOR MODULE CORNERS
;	A = SHIP #
;	ROUTINE EXITS W/XPOLAN TO YPOLAN+1 HAVING PROPER OFFSET
;	FROM X & Y (SHIP LABS POINT)
;
CNVRT:	STX	TBLADDR+1
	STY	TBLADDR
	BIT	LUNARNUM
	BVS	40$			;LITTLE MODULES
	LDA	SHIP
	ASL
	TAY
	LDX	I,0
	LDA	NY,TBLADDR	;A = DELTA X
	BPL	10$		;DELTA X IS POSITIVE
	DEX			;EXTEND SIGN
10$:	CLC
	ADC	XCURR
	STA	XPOLAN		;XPOLAN = NEW X POSITION
	TXA			;TOP BYTE
	ADC	XCURR+1
	STA	XPOLAN+1
20$:	INY
	LDX	I,0
	LDA	NY,TBLADDR	;A = DELTA Y
	BPL	30$		;DELTA Y IS POSITIVE
	DEX			;EXTEND SIGN
30$:	CLC
	ADC	YCURR
	TAY			;YPOLAN = NEW Y POSITION
	TXA			;TOP BYTE
	ADC	YCURR+1
	BNE	50$		;ALWAYS
40$:	LDA	XCURR
	STA	XPOLAN
	LDA	XCURR+1
	STA 	XPOLAN+1
	LDY	YCURR
	LDA	YCURR+1
50$:	AND	I,0F
	STA	YPOLAN+1
	STY	YPOLAN
	RTS

	.SBTTL	DISTANCE CALCULATION
;
;
;
DISTNC:	LDA	XPOS		;GET DELTA X OF SEGMENT (ALWAYS <= 255.)
	SEC			;XPOS ALWAYS >= XPRE
	SBC	XPRE
	STA	DELX		;DELX=DELTA X (SCAPE SEGMENT)
	LDA	YPRE		;2'S COMP LEFT ENDPT (Y VALUE)
	EOR	I,0FF
	TAY
	LDA	YPRE+1
	EOR	I,0FF
	TAX
	INY
	BNE	5$
	INX			;ADD ROLLOVER
5$:	TYA			;ADD ENDPOINTS (REALLY YPOS - YPRE)
	CLC
	ADC	YPOS
	TAY
	TXA
	LDX	I,0		;X=SLOPE SIGN BYTE (ASSUME PLUS)
	ADC	YPOS+1		;SIGN BIT (D7)=SLOPE SIGN
	BPL	10$		;BRANCH - SLOPE POSITIVE (Y=DELTA Y)
	TYA			;ELSE - 2'S COMP DELTA Y (MAGNITUDE)
	EOR	I,0FF
	TAY
	DEX			;X=0FF
10$:	STX	DELY+1		;DELY+1=SIGN OF SLOPE
	RTS
;
;
;
DSTNCY:	JSR	DISTNC
	TYA
	LDY	DELX
	JSR	DIVIDE		;QUOT=QUOTIENT (=SEGMENT SLOPE)
	LDA	XPOLAN
	SEC
	SBC	XPRE
	LDY	QUOT+1
	JSR	MULTPA
	STX	TEMP1		;DELTA Y <= 255.
	LDY	QUOT
	JSR	MULTPB
	CLC
	ADC	TEMP1		;DELTA Y (INCLUDES FRACTIONAL ROLLOVER)
	STA	TEMP1
	BIT	DELY+1
	BMI	40$		;DELTA Y IS NEGATIVE
	CLC
	ADC	YPRE
	STA	SUMSOR		;SUMSOR=YPRE+DELTA Y
	LDA	YPRE+1
	ADC	I,0
	STA	SUMSOR+1
	JMP	CDISY
40$:	SEC
	LDA	YPRE
	SBC	TEMP1
	STA	SUMSOR		;SUMSOR=YPRE-DELTA Y
	LDA	YPRE+1
	SBC	I,0
	STA	SUMSOR+1
CDISY:	LDX	YPOLAN
	LDA	YPOLAN+1
	JSR	SUMDIST		;GET DISTANCE FROM SHIP CORNER TO SCAPE
	BPL	10$		;SIGN=SIGN OF RESULT
	LDX	I,8F
	STX	COLFLG
10$:				;A & Y =DISTANCE (Y AXIS)
	RTS
;
;
;
DSTNCX:	JSR	DISTNC
	LDA	DELX
	JSR	DIVIDE		;QUOTIENT=1/SLOPE
	LDA	YPRE
	SEC
	SBC	YPOLAN
10$:	LDY	QUOT+1
	JSR	MULTPA
	STX	TEMP1
	LDY	QUOT
	JSR	MULTPB
	CLC
	ADC	TEMP1
	STA	TEMP1		;TEMP1=DELTA X(INCLUDES FRACTION ROLLOVER)
	CLC
	ADC	XPRE
	STA	SUMSOR
	LDA	XPRE+1
	ADC	I,0
	STA	SUMSOR+1
	LDX	XPOLAN
	LDA	XPOLAN+1
				;CONTINUE TO SUMDIST
;
;	SUMDIST WILL CONVERT ENDPT (2'S COMP.) IF NEGATIVE
;	AND THEN CALL SUMSA TO DETERMINE DISTANCE BETWEEN
;	SCAPE AND MODULE
;
;	ACC,X = MODULE POINT (EITHER X-AXIS OR Y-AXIS)
;
SUMDIST:STA	SUMDES+1	;CHECK FOR MINUS ENDPOINTS
				;= EDGE OF DISPLAY (SCREEN)
	LDA	I,80
	BIT	SUMSOR+1	;CHK FOR BELOW 0,0 (-ENDPT)
	BPL	10$		;BRANCH - NO
	LDA	SUMSOR		;ELSE - 2'S COMP ENDPT
	EOR	I,0FF
	STA	SUMSOR
	LDA	SUMSOR+1
	EOR	I,0FF
	STA	SUMSOR+1
	INC	SUMSOR
	BNE	5$
	INC	SUMSOR+1
5$:	LDA	I,0		;AND ADD RESULT TO SHIP CORNER
10$:	STA	SSORSGN		;STORE SIGN TO ADD OR SUBTRACT ENDPT
	LDY	I,0
	STY	SDESSGN		;Y = 0 (FOR MODULE POINT (POSITIVE))
	JMP	SUMSC		;ADD SHIP CORNER TO ENDPOINT
				;= DISTANCE
;
;	ACC=DIVIDEND
;	DIVSOR=DIVISOR
DIVIDE:	STY	DIVSOR
	JSR	DIVIT
	STX	QUOT+1		;MSB OF QUOT STORED
	LDX	I,0
	STX	MQ
	JSR	DIVIT1
	STX	QUOT		;LSB OF QUOT STORED (FRACTION)
	RTS
;
;
;
DIVIT:	STA	MQ
	LDA	I,0
DIVIT1:	LDY	I,7
10$:	ROL	MQ
	ROL
	BCS	30$
	CMP	DIVSOR
	BCC	20$
	SBC	DIVSOR
20$:	DEY
	BPL	10$
	ROL	MQ
	LDX	MQ
	RTS
30$:	SBC	DIVSOR
	SEC
	BCS	20$
;
;	MULTIPLY ROUTINE	PROD=PRODUCT
;	MULTC=MULTIPLICAND, MULTR=MULTIPLIER (NEITHER ZAPPED)
;
MULTPA:	STA	MULTC
MULTPB:	STY	MULTR
MULTIPLY:LDA	MULTC
	PHA
	EOR	I,0FF
	STA	MULTC
	LDA	I,0
	STA	PROD
	STA	PROD+1
	LDX	I,8
10$:	ASL	MULTC
	BCS	20$
	ADC	MULTR
	BCC	20$
	INC	PROD+1
20$:	DEX
	BNE	30$
	TAX
	PLA
	STA	MULTC
	LDA	PROD+1
	RTS
30$:	ASL
	ROL	PROD+1
	BCC	10$		;ALWAYS BRANCH
;
;
	.SBTTL	CHKSUM #10 (7000 - 73FF)  [10]
	.BYTE	0
	.PAGE
	.SBTTL	LUNARSCAPE CHANGE
;
;
;
SCAPCHG:LDA	I,0		;INITIALLY NO SCROLLING
	STA	MJRFLG
	STA	MJRFLG+2
	LDA	I,0F		;ASSUME MINOR (SCROLL ON X AXIS)
	BIT	LUNARNUM
	BVC	10$		;BRANCH - MINOR
	LDA	I,3		;ELSE - MAJOR MASK
10$:	STA	TEMP1		;SAVE AND MASK
	LDA	XCURADJ+1
	BIT	SGNVLX
	BPL	20$
	CMP	I,XMIN		;VELX IS NEGATIVE
	BCS	30$
	JSR	XSCPSUB		;SCROLL SCAPE LEFT WHEN SHIP IS MIN. X
	BCS	30$
	DEC	LUNAROT
	BCC	25$		;ALWAYS BRANCH (CARRY IS CLR)
20$:	CMP	I,XMAX		;VELX IS POSITIVE
	BCC	30$
	JSR	XSCPADD		;SCROLL SCAPE RIGHT WHEN SHIP IS MAX. X
	BCC	30$
	INC	LUNAROT
25$:	LDA	LUNAROT
	AND	TEMP1		;AND MASK FOR SCAPE
	STA	LUNAROT
30$:	BIT	LUNARNUM	;CURRENTLY DISPLAYED
	BVC	40$
	JMP	SCAPMJR		;...MAJOR
40$:	LDA	YCURADJ+1	;...MINOR
	BIT	SGNVLY
	BPL	60$
	CMP	I,YMIMIN	;VEL Y IS NEGATIVE
	BCS	50$
	JSR	YSCPSUB		;SCROLL MINOR UP
50$:	JMP	SCAPLND
60$:	CMP	I,YMIMAX	;VEL Y IS POSITIVE
	BCC	50$
	JSR	SCPDST		;A,X = MIN DISTANCE (SCAPE TO MODULE)
	CMP	I,YMISCR/100
	BCC	64$
	BNE	65$
	CPX	I,YMISCR&0FF
	BCS	65$
64$:	JSR	YSCPADD
	JMP	SCAPLND
65$:	BIT	COLFLG		;IS MODULE IN CONTACT WITH SCAPE ?
	BPL	SCRLUP		;BRANCH - NO, BOTH CORNERS CLEAR
70$:	JMP	COLLIDE		;ELSE - COLLISION
;
;CONVERT MINOR OFFSETS INTO MAJOR OFFSETS
;
SCRLUP:	LDA	XCURR			;COMPUTE SUM TOTAL OF SHIP'S
	CLC				;RELATIVE POSITIONS
	ADC	SCROLL+1	
	STA	SCROLL+1		;=(XCURR+[SCROLL+1])+256.*([XCURR+1])
	LDA	XCURR+1			; &3+LUNAROT)
	AND	I,3
	ADC	LUNAROT
	AND	I,0F
	TAX
	LSR
	ROR	SCROLL+1
	LSR
	ROR	SCROLL+1		;A,SCROLL+1=NEW SHIP X POSITION
	CLC
	ADC	I,2
	AND	I,3
	STA	LUNAROT			;MAJOR LUNAROT
	TXA
	AND	I,0C			;A=4*LUNAROT OF MAJOR
	PHA
	ASL
	ASL
	TAX
	LDA	AX,MINTBL
	SEC
	SBC	SCRADD+1
	STA	SUMSOR
	LDA	AX,MINTBL+1
	SBC	SCRADD+2
	STA	SUMSOR+1		;SUMSOR=POSITION OF MINOR PAGE
	LDA	I,80			;BEGINNING
	STA	SSORSGN
	LDY	I,0
	LDX	YCURR
	LDA	YCURR+1
	AND	I,0F
	JSR	SUMSA			;SUMDES=SHIP Y POSITION - LUNARSCAPE
	LSR				;SECTION STARTING ADDR
	ROR	SUMDES
	LSR
	ROR	SUMDES
	STA	SUMDES+1		;SUMDES=1/4*MINOR DISTANCE
	PLA
	TAX
	LDA	AX,LUNMJ0
	STA	SUMSOR
	LDA	AX,LUNMJ0+1		;ADD IN LOCATION OF MAJOR PAGE
	STA	SUMSOR+1		;BEGINNING
	LDA	I,0
	STA	SCROLL
	STA	SCRADD
	STA	SCRADD+1
	STA	SCRADD+2
	STA	YCURADJ
	STA	XCURADJ
	STA	SSORSGN
	JSR	SUMSUM			;A,Y=MAJOR SHIP Y POSITION
	STY	YCURADJ+1
	LSR
	ROR	YCURADJ+1
	ROR	YCURADJ
	LSR
	ROR	YCURADJ+1
	ROR	YCURADJ
	LDA	I,RMJRX
	STA	XCURADJ+1
	LDA	I,40
	STA	LUNARNUM	;DISPLAY MAJOR
	RTS
SCAPLND:JSR	SCPDST
20$:	ORA	I,0		;A,X = SMALLEST Y DISTANCE
	BNE	35$		;DISTANCE > 255.
	CPX	I,2		;LANDING DISTANCE = 1. (*****)
	BCS	35$
	CPY	I,2		;    "       "    (OTHER CORNER)
	BCS	35$
	LDA	SHIP
	SEC
	SBC	I,7
	CMP	I,3
	BCS	COLLIDE		;LANDING ONLY SHIPS #7,8 & 9
	LDA	VELY+1
	LDX	I,80
	CMP	I,4
	BCC	30$
	CMP	I,8
	BCS	COLLIDE
	LDX	I,0C0
30$:	LDA	VELX+1
	CMP	I,4		;CHECK X VELOCITY
	BCS	COLLIDE		; CRASH (TOO GREAT)
	TXA
	ORA	COLFLG
	STA	COLFLG
	RTS			;SUCCESSFUL LANDING
35$:	BIT 	COLFLG		;CHECK IMPACT
	BPL	COLLEX		;BRANCH-OK
COLLIDE:LDA	I,8F
	STA	COLFLG		;COLLISION
COLLEX:	RTS
;
;
;
SCAPMJR:LDA	YCURADJ+1
	BIT	SGNVLY
	BMI	30$
	CMP	I,YMJMAX	;VEL Y IS POSITIVE
	BCC	40$		;CHK FOR MINOR JUMP
25$:	JSR	YSCPADD
	BEQ	28$
27$:	CMP	I,2		;CHECK FOR MAX SHIP Y
	BCC	28$		;BRANCH - NO, NOT YET
	JSR	INTWAIT		;WAIT FOR FRAME END & RESTART
	JSR	DEDCTA
	LDX	I,INITSTK
	TXS
	JMP	PLYSTRT		;RESET GAME
28$:	RTS			;FINISHED
30$:	LDA	SCRADD+1	;CHECK FOR UP SCROLL
	ORA	SCRADD+2
	BEQ	40$
	JSR	YSCPSUB
	BCS	28$
	LDA	I,0
	STA	SCRADD
	STA	SCRADD+1
	STA	SCRADD+2
35$:	RTS			;SCROLL UP MAJOR
40$:	JSR	SCPDST
	TAY
	BNE	35$		;DISTANCE > 255.
	CPX	I,YMJMIN
	BCS	35$		;DISTANCE >= 96.
	LDA	XCURR
	CLC
	ADC	SCROLL+1
	STA	SCROLL+1
	LDA	XCURR+1
	ADC	LUNAROT
	AND	I,3
	TAX				;X=MAJOR SECTION CONTAINING SHIP
	ASL	SCROLL+1
	ROL
	ASL	SCROLL+1
	ROL
	PHA			;SAVE ACC (= MINOR SECTION CONTAINING SHIP)
	SEC
	SBC	I,2
	AND	I,0F
	STA	LUNAROT			;LUNAROT=MINOR SECTION @ BEGINNING OF SCREEN
	TXA
	ASL
	ASL
	TAX				;X=OFFSET FOR LABS OF MAJOR SECTION
	LDA	AX,LUNMJ0
	STA	SUMSOR
	LDA	AX,LUNMJ0+1
	STA	SUMSOR+1
	LDA	I,80
	STA	SSORSGN
	LDA	YCURR+1
	LDX	YCURR
	LDY	I,0
	JSR	SUMSA			;SUMDES, ACC=DISTANCE FROM SECTION
	ASL	SUMDES			;ORIGIN TO SHIP
	ROL
	ASL	SUMDES
	ROL
	STA	SUMDES+1
	LDA	I,MNSETY/100
	LDX	I,MNSETY&0FF
	STA	SUMSOR+1
	STX	SUMSOR
	JSR	SUMSUM			;SUMDES, SUMDES+1=STARTING ORIGIN
	LDA	I,MINORG&0FF		;OF MINOR SECTION
	STA	SUMSOR
	LDA	I,MINORG/100
	STA	SUMSOR+1
	LDA	I,0
	STA	SSORSGN
	STA	LUNARNUM
	STA	XCURADJ
	STA	YCURADJ
	STA	SCROLL
	STA	SCRADD
	JSR	SUMSUM			;SUMDES, SUMDES+1=SCROLLING
					;NECESSARY FOR MINOR
	PLA			;ACC = MINOR SECTION CONTAINING SHIP
	AND	I,0C
	ASL
	TAX
	LDA	AX,MINTAB
	STA	SUMSOR
	LDA	AX,MINTAB+1
	STA	SUMSOR+1
	JSR	SUMSUM			;SUMDES,SUMDES+1=VERTICAL SCROLL
					;VALUES FOR MINOR SCAPE
	STA	SCRADD+2
	STY	SCRADD+1
	LDA	I,MINSTX
	STA	XCURADJ+1
	LDA	I,MINSTY
	STA	YCURADJ+1
	RTS
;
SCPDST:	LDY	I,0FF		;CHECK Y AXIS DISTANCES
	LDA	DISTYL+1	;ASSUME Y(LEFT) IS LEAST
	LDX	DISTYL
	CMP	DISTYR+1	;COMPARE TOP BYTES
	BCC	20$		;BRANCH - Y(LEFT) SMALLER
	BNE	10$		;BRANCH - Y(RIGHT) SMALLER
				;TOP BYTES EQUAL
	LDY	DISTYR		;THEN, Y=OTHER LOWER BYTE (LARGEST)
	CPY	DISTYL		;CHECK IF DISTYL IS SMALLER
	BCS	20$		;BRANCH - SMALLER OR EQUAL
				;ELSE - DISTYR IS SMALLER
	LDX	DISTYR		;X=SMALLER OF LOWER BYTES
	LDY	DISTYL
	BCC	20$		;ALWAYS
10$:	LDA	DISTYR+1	;DISTYR < DISTYL
	LDX	DISTYR
20$:	RTS
;
;
XSCPADD:JSR	ROTX
	LDA	SCROLL
	CLC
	ADC	DELX
	STA	SCROLL
	LDA	SCROLL+1
	ADC	DELX+1
	STA	SCROLL+1
	RTS
;
XSCPSUB:JSR	ROTX
	LDA	SCROLL
	SEC
	SBC	DELX
	STA	SCROLL
	LDA	SCROLL+1
	SBC	DELX+1
	STA	SCROLL+1
	RTS
;
YSCPADD:JSR	ROTY
	LDA	SCRADD
	CLC
	ADC	DELY
	STA	SCRADD
	LDA	SCRADD+1
	ADC	DELY+1
	STA	SCRADD+1
	LDA	SCRADD+2
	ADC	I,0
	STA	SCRADD+2
	RTS
;
YSCPSUB:JSR	ROTY
	LDA	SCRADD
	SEC
	SBC	DELY
	STA	SCRADD
	LDA	SCRADD+1
	SBC	DELY+1
	STA	SCRADD+1
	LDA	SCRADD+2
	SBC	I,0
	STA	SCRADD+2
	RTS
;
ROTX:	LDA	I,80		;ROTX IS USED TO SCROLL SCAPE LEFT OR RIGHT ONCE
	STA	MJRFLG		;MODULE HAS REACHED THE MIN/MAX OF ITS HORIZ. MOTION RANGE
	LDA	VELX+1		;AN ADJUSTED VELOCITY IS COMPUTED W/ RELATION TO TYPE OF SCAPE
	STA	DELX		;DELX+1, DELX WILL HOLD ADJUSTED X VELOCITY
	LDA	I,0
	STA	DELX+1
	LDA	VELX
	LDX	I,2		;IF MAJOR IS DISPLAYED THEN ADJ. VEL = 2 * VEL
	BIT	LUNARNUM	;CHECK SCAPE
	BVS	10$		;BRANCH - MAJOR
	LDX	I,4		;ELSE - MINOR ADJ. VEL = 4 * VEL X
10$:	ASL			;ADJUST VELOCITY (MULTIPLY BY 2)
	ROL	DELX
	ROL	DELX+1
	DEX
	BNE	10$		;REPEAT FOR [X] TIMES
	RTS
;
ROTY:	LDA	I,80
	STA	MJRFLG+2
	LDA	VELY+1
	STA	DELY
	LDA	I,0
	STA	DELY+1
	LDA	VELY
	LDX	I,2
	BIT	LUNARNUM
	BVS	10$
	LDX	I,4
10$:	ASL
	ROL	DELY
	ROL	DELY+1
	DEX
	BNE	10$
	RTS
	.PAGE
	.SBTTL	DYNAMIC LUNARMAJOR, MAJOR LANDING SITES, LANG,FOREIGN DATA
;
;COMPUTE LUNARMAJOR FROM LUNARMINOR SCAPE
;
TRANS:	LDA	I,LNMIN&0FF	;INITIALIZE POINTERS
	STA	RAMLD
	LDA	I,LNMIN/100
	STA	RAMLD+1		;RAMLD=LUNAR MINOR LIST (IN VG ROM)
	LDA	I,MJRVG/100
	STA	RAMPTR+1	;RAMPTR=LUNAR MAJOR LIST (IN VG RAM)
	LDA	I,STKSPCE&0FF
	STA	STACK		;STACK SAVES SECTION RETURN POINTERS
	LDA	I,0
	STA	RAMPTR
	STA	STACK+1
	STA	TEMP1		;CLR TEMPS
	STA	TEMP2
	STA	TEMP3
	LDA	I,MJRLST&0FF
	STA	POINTR		;POINTR=LUNAR MAJOR SECTION JSRLS (IN VG RAM)
	LDA	I,MJRLST/100
	STA	POINTR+1
TRANSA:	JSR	TRLIST		;PUT JSRL ONTO LIST
	LDY	I,0
TRANSLP:LDA	NY,RAMLD	;GENERAE MAJOR BY MAKING MINOR VCTRS/ALPHS
	TAX			;1/4 AS LONG AND COPYING INTO VG RAM
	INY
	LDA	NY,RAMLD
	CMP	I,0A0
	BCC	TRNVCTR		;BRANCH-VECTOR INSTR
	CMP	I,0D0
	BCC	TRNJSRL		;JSRL INSTR (EITHER SEGMENT OR SECTION)
	BEQ	TRNRTSL		;RTSL INSTR (FROM SEGMENT OR SECTION)
TRNALPH:STA	NY,RAMPTR	;ALPH INSTR
	DEY
	TXA
	EOR	I,8		;BLANK XAS BIT (DELTA X & DELTA Y DIVIDED BY 4)
	STA	NY,RAMPTR
	INY
	INY
	BNE	TRANSLP
TRNVCTR:SEC
	SBC	I,20		;VCTR TIMER (SUBTRACT 2)
	STA	NY,RAMPTR	;DELTA X & DELTA Y DIVIDED BY 4
	DEY
	TXA
	STA	NY,RAMPTR
	INY
	INY
	LDA	NY,RAMLD	;COPY BYTE 2 & 3 OF VCTR INSTR
	STA	NY,RAMPTR
	INY
	LDA	NY,RAMLD
	STA	NY,RAMPTR
	INY
	BNE	TRANSLP		;ALWAYS
TRNJSRL:AND	I,0F
	STA	TEMP4		;SAVE JSRL ADDRESS
	STX	TEMP5
	DEY
	JSR	TRNINC		;UPDATE RAMPTR(WITH CONTENTS OF REG Y)
	INY
	INY
	TYA
	LDY	I,0
	CLC
	ADC	RAMLD
	STA	NY,STACK	;SAVE RETURN RAMLD (MINOR LIST) ON STACK
	INC	STACK
	LDA	RAMLD+1
	ADC	I,0
	STA	NY,STACK
	INC	STACK
	LDA	TEMP5		;SET RAMLD TO NEW VG SUBROUTINE
	ASL
	STA	RAMLD
	LDA	TEMP4
	ROL
	ORA	I,40
	STA	RAMLD+1
	BNE	TRANSLP		;ALWAYS (ADJUST POINTER FROM JSRL INSTR)
TRNRTSL:DEY
	JSR	TRNINC		;UPDATE RAMPTR
	LDY	I,0
	DEC	STACK
	LDA	NY,STACK
	STA	RAMLD+1		;GET RETURN POINTER FROM STACK
	DEC	STACK
	LDA	NY,STACK
	STA	RAMLD
	LDX	STACK
	CPX	I,STKSPCE&0FF	;CHK FOR EMPTY STACK=END OF ONE SECTION
	BNE	TRANSLP		;     		  =64. ON MAJOR X-AXIS
	INC	TEMP1		;CHECK FOR ADDING TO JSRL LIST
	LDX	I,4		;4 MINOR SECTIONS=1 MAJOR SECTION= 256. ON X-AXIS
	CPX	TEMP1
	BNE	TRANSLP
	LDA	I,0
	STA	TEMP1
	STA	NY,RAMPTR
	INY
	LDA	I,0D0		;INSERT RTSL INTO MAJOR SECTION
	STA	NY,RAMPTR
	INY
	JSR	TRNINC		;UPDATE RAMPTR (W/[Y])
	INC	TEMP3
	LDX	I,4
	CPX	TEMP3		;CHECK FOR ALL 4 SECTIONS OF MAJOR
	BEQ	TRNEXT		;EXIT-FOURTH SECTION COMPLETE
	JMP	TRANSA		;INSERT JSRL & CONTINUE W/NEXT VG INSTR
TRNEXT:	LDA	I,MJRLST&0FF	;COPY JSRL'S INTO 2ND HALF OF
	STA	RAMLD		;MAJOR JSRL LIST FOR SCAPE WRAP AROUND
	LDA	I,MJRLST/100
	STA	RAMLD+1
	LDA	TEMP2
	CLC
	ADC	POINTR
	STA	POINTR
	BNE	10$
	INC	POINTR+1
10$:	LDY	I,7		;MJRLST[8]=MJRLST[0]....MJRLST[15.]=MJRLST[7]
20$:	LDA	NY,RAMLD	;FINISH JSRL LIST
	STA	NY,POINTR
	DEY
	BPL	20$
;
	LDA	I,TBMNV&0FF	;CONSTRUCT MAJOR SITE VCTRS FROM MINORS'
	STA	RAMLD
	LDA	I,TBMNV/100	;TBMNV=TABLE OF MINOR VCTRS (SOURCE)
	STA	RAMLD+1
	LDA	I,TBVCTR&0FF	;TBVCTR=TABLE OF MAJOR VCTRS (DESTINATION)
	STA	RAMPTR
	LDA	I,TBVCTR/100
	STA	RAMPTR+1
	LDY	I,0
	LDX	I,0
TRSITE:	LDA	NY,RAMLD	;FOR VCTR INSTR. SUBTRACT 2 FROM TIMER
	CPX	I,1		;CHK FOR SITE VCTR
	BNE	10$		;NO-BRANCH
	SEC
	SBC	I,20
	BNE	20$		;ALWAYS
10$:	CPX	I,7		;CHK FOR OFFSET VCTR
	BNE	20$		;NO-BRANCH
	AND	I,3
	STA	TEMP1		;FOR OFFSET VCTR
	DEY			;DIVIDE DELTA X BY 4
	LDA	NY,RAMLD
	LSR	TEMP1
	ROR
	LSR	TEMP1
	ROR
	STA	NY,RAMPTR
	INY
	LDA	I,4		;DELTA X SIGN (BIT 2) IS NEGATIVE
20$:	STA	NY,RAMPTR	;LOAD BYTE INTO TBVCTR
	INX
	TXA
	AND	I,7		;X=0 TO 7 (8 BYTES=SITE VCTR & OFFSET VCTR)
	TAX
	INY
	CPY	I,20		;Y COUNTS # OF BYTES (32. IN TABLE)
	BCC	TRSITE
	LDA	LANG		;GET LANGUAGE
;
;GENERATE FOREIGN LANGUAGE PLAYER ALPHA STRINGS
;
;FMESSG=TABLE OF POINTER TO FOREIGN LANGUAGE PLAYER ALPHAS
;V.G. INSTRUCTIONS WILL BE CALCUALTED & LOADED INTO VGRAM @ F.ALPH
;
	BEQ	TNEXIT		;NO CALCULATION FOR ENGLISH
	LDX	I,5
	STX	TEMP1		;TEMP1=COUNTER (6 ALPHA STRNGS)
	ASL
	TAX
	DEX
	DEX			;X=2 * (LANG-1)
	LDA	I,F.ALPH&0FF
	STA	RAMPTR
	LDA	I,F.ALPH/100
	STA	RAMPTR+1
	LDA	AX,FMESSG+1	;A,Y=ADDRESS OF LIST
	LDY	AX,FMESSG
	JSR	LODRM8		;LOAD LABS & WAIT (8 BYTES)
40$:	LDX	RAMLD+1		;X,Y=POINTER TO .ASCVG LIST
	LDY	RAMLD
	JSR	DSPLAA		;LOAD CHARACTER JSRL'S
	LDA	POINTR+1
	LDY	POINTR		;A,Y = POINTER TO OFFSET VCTR
	JSR	LODRM4		;LOAD VCTR
	DEC	TEMP1
	BPL	40$
TNEXIT:
	RTS
;
TRNINC:	TYA			;UPDATE RAMPTR
	CLC
	ADC	RAMPTR
	STA	RAMPTR
	BCC	10$
	INC	RAMPTR+1
10$:	RTS
;
TRLIST:	LDA	RAMPTR+1	;CONSTRUCT JSRL'S TO
	LSR			;LUNAR MAJOR SECTIONS
	AND	I,0F
	ORA	I,0C0		;JSRL OP CODE IS C0
	TAX
	LDA	RAMPTR
	ROR
	LDY	TEMP2
	STA	NY,POINTR	;STORE JSRL INTO VGRAM
	TXA
	INY
	STA	NY,POINTR
	INY
	STY	TEMP2		;TEMP2=OFFSET FOR NEXT JSRL
	RTS
;
;
	.SBTTL	CHKSUM #11 (7400 - 77FF)  [0C]
	.BYTE	0
	.PAGE
	.SBTTL	DISPLAY DATA ROUTINES
;
;	GENERATE DISPLAYED VALUES
;
DISPLY:	LDX	I,3		;DISPLAY VALUE OFFSET
	STX	TEMP3		;SAVE IT
	LDX	I,2		;VARIABLE OFFSET
5$:	LDA	ZX,VELX+1	;HIGH BYTE OF VELOCITY
	LDY	ZX,VELX		;LOW BYTE
	STY	TEMP1
	LDY	I,9		;CNVRT TOP 10 BITS OF VELOCITY INTO DECIMAL
	STX	TEMP4		;SAVE OFFSET
	TAX
	JSR	DECCNV		;CONVERT BINARY TO DECIMAL
	PHA
	TXA
	LDX	TEMP3
	STA	ZX,VELOCX+1	;STORE DECIMAL VALUES
	STY	ZX,VELOCX+2
	PLA
	STA	ZX,VELOCX
	LDX	TEMP4		;SGNVL? OFFSET
	LDY	I,2		;ASSUME BLANK
	ORA	NUMB3		;CHECK FOR ZERO
	ORA	NUMB2
	BEQ	10$		;VELOCITY = 0 (NO ARROWS)
	LDA	ZX,SGNVLX	;CHECK SIGN OF VELOCITY
	ASL
	LDA	I,0		;RIGHT/UP (POSITIVE)
	ROL			;LEFT/DOWN (NEGATIVE)
	TAY
10$:	TXA
	LSR
	TAX			;X = OFFSET FOR ARROW VARIABLE
	STY	ZX,ARRWX	;SET ARROW STATUS
	LDA	I,0
	STA	TEMP3		;SET TEMP3 FOR VELX
	LDX	TEMP4
	DEX
	DEX			;DO VELX
	BPL	5$
	JSR	SCPDST		;A,X=MIN DISTANCE
	STX	TEMP1		;SAVE LOWER BYTE
	BIT	LUNARNUM	;WHICH SCAPE
	BVC	20$		;BRANCH - MINOR
	ASL	TEMP1		;MAJOR*4
	ROL
	ASL	TEMP1
	ROL
20$:	TAX			;X=TOP BYTE
	LDY	TEMP1		;Y=LOWER BYTE
35$:	JSR	DECIMAL		;CONVERT ALTIUDE TO DECIMAL
	STA	ALTITD
	STX	ALTITD+1
	STY	ALTITD+2
	RTS
;
POINTS:	LDX	I,15		;HARD = 15 PTS
	BIT	COLFLG
	BVS	PNTS1
	LDX	I,5		;CRASH = 5 PTS
	LDA	COLFLG
	AND	I,0F
	BNE	PNTS1
	LDX	I,50		;SUCCESSFUL=50 PTS
PNTS1:	SED
	TXA		;ACC = SCORE AMOUNT
	CLC
	ADC	SCORE		;UPDATE SCORE
	STA	SCORE
	LDA	SCORE+1		;NEED DECIMAL ADD
	ADC	I,0
	STA	SCORE+1
	CLD
	RTS
;
;BOOM - EXPLOSION SEQUENCE
;
;THIS ROUTINE ASSUMES THAT THE BEAM IS POSITIONED AT THE CENTER OF THE
;EXPLOSION
;
;ENTRY	(INDEX) = STEP NUMBER FOR EXPLOSION (0-127)

;
GLBNUM	=12.
;
BOOM:	LDX	I,12.		;NUMBER OF PIECES*2-2
	LDA	I,0
	STA	VGBRIT
BMLOOP:	TXA
	LSR
	TAY
	LDA	AY,BOOMC1
	CMP	INDEX
	BCC	30$		;PIECE NOT TO BE DISPLAYED
	STX	TEMP4
	JSR	BMVCPI
	CPX	I,GLBNUM
	BNE	12$
	CLC
	ADC	DELX
12$:	JSR	MULT		;X*INDEX
	STX	XCOMP
	STY	XCOMP+1
	LDX	TEMP4
	INX
	JSR	BMVCPI
	DEX
	CPX	I,GLBNUM
	BNE	14$
	CLC
	ADC	DELY
14$:	JSR	MULT		;Y*INDEX
	STX	XCOMP+2
	STY	XCOMP+3
				;CHECK FOR MAXIMUM VECTORS
	TYA
	BPL	16$
	EOR	I,0FF
	TAY
	TXA			;CNVRT	(ABSOLUTE X & Y)
	EOR	I,0FF
	TAX
	INX
	BNE	16$
	INY
16$:	CPY	I,4		;CARRY SET IF X,Y > 1023.
	BCS	35$		;EXIT WHEN REACHED
	JSR	VGVCTR		;GENERATE VECTOR TO STARTING POINT (OR DELTA)
	LDY	I,0
	LDX	TEMP4
	CPX	I,12.		;CHK FOR OCTAGON
	BNE	17$
	LDA	INDEX
	AND	I,7
	ASL
	TAX
	LDA	AX,OCTGN
	STA	NY,VGLIST
	INY
	LDA	AX,OCTGN+1
	STA	NY,VGLIST
	BNE	18$		;ALWAYS	BRANCH
17$:	JSR	BMPIEC
	TYA
	LDY	TEMP1
	STA	NY,VGLIST	;PUT JSRL TO DEBRIS PICTURE INTO VECTOR LIST
	INY
	INX
	JSR	BMPIEC
	TYA
	DEX
	LDY	TEMP1
	STA	NY,VGLIST
18$:	JSR	VGADD		;UPDATE VGLIST
	LDX	TEMP4
30$:	DEX
	DEX
	BPL	BMLOOP		;LOOP THRU ALL PIECES
35$:	LDA	INDEX		;CALCULATE EXPLOSION SOUND
 	EOR	I,7F
	CMP	I,40
	BCC	40$
	LSR
	LSR
	LSR
	ORA	I,NSPITC	;ENABLE HI-FREQ NOISE
	TAX			;SOUND LEVEL FOR CRASH
	LDA	I,20		;CLEAR LOW FUEL SOUND
	JMP	S.SND		;OUTPUT TO SOUND CIRCUIT
40$:	RTS
;
BMPIEC:	STY	TEMP1		;SAVE Y
BMVCPI:	LDA	RNDOM		;EXPLOSION PICTURE BY RANDOM
	BEQ	30$
	CMP	I,2
	BCC	20$
	BEQ	10$
	LDA	AX,BOOMA4
	LDY	AX,BOOMB4
	RTS
10$:	LDA	AX,BOOMA3
	LDY	AX,BOOMB3
	RTS
20$:	LDA	AX,BOOMA2
	LDY	AX,BOOMB2
	RTS
30$:	LDA	AX,BOOMA1
	LDY	AX,BOOMB1
	RTS
;
BOOMA1:	.BYTE	0,-2		;(X,Y) VALUES OF EACH PIECE OF DEBRIS
	.BYTE	-1,-1
	.BYTE	-2,0
	.BYTE	-1,0
	.BYTE	0,2
	.BYTE	2,-1
	.BYTE	0,3		;OCTAGON TRAVEL

;
BOOMA2:	.BYTE	2,1
	.BYTE	0,1
	.BYTE	-4,1
	.BYTE	-1,-1
	.BYTE	2,0
	.BYTE	0,-1
	.BYTE	0,2		;OCTAGON
;
BOOMA3:	.BYTE	-1,0
	.BYTE	-3,0
	.BYTE	1,0
	.BYTE	-1,-1
	.BYTE	0,-1
	.BYTE	3,0
	.BYTE	0,3		;OCTAGON
;
BOOMA4:	.BYTE	1,-1
	.BYTE	-5,0
	.BYTE	1,-1
	.BYTE	3,1
	.BYTE	-1,-3
	.BYTE	1,1
	.BYTE	0,3		;OCTAGON
;
BOOMC1:	.BYTE	5D		;WHEN PIECE SHOULD DISAPPEAR
	.BYTE	60
	.BYTE	64
	.BYTE	6D
	.BYTE	70
	.BYTE	74
	.BYTE	7F		;OCTAGON
;
;CALCULATE EXPLOSION DELTAS (X&Y)
;
DELTA:	LDA	VELY+1
	LSR
	LSR
	LSR
	CMP	I,8
	BCC	2$
	LDA	I,7
2$:	STA	DELY
	LDA	VELX+1
	LSR
	LSR
	CMP	I,8
	BCC	4$
	LDA	I,7
4$:	BIT	SGNVLX
	BMI	6$
	EOR	I,0FF
	CLC
	ADC	I,1
6$:	STA	DELX
	LDA	INTCNT		;GENERATE RANDOM # FOR LAND/CRASH MESSAGES
	LSR
	LSR
	AND	I,3
	STA	RNDOM
	RTS
;
;MULT - MULTIPLY INDEX BY A SIGNED NUMBER
;
;ENTRY	(A) = MULTIPLIER (SIGNED -128 TO 127)
;	(INDEX) = MULTIPLICAND (0 TO 127)
;EXIT	(X) = LSB OF RESULT
;	(Y) = MSB OF RESULT
;USES	A,X,Y,TEMP1,TEMP2,TEMP3
MULT:	LDY I,0
	STA TEMP2		;SAVE OPERAND
	ASL
	LDA INDEX
	STA TEMP1		;MULTIPLICAND
	BCC 10$
	LDY I,0FF		;SIGN EXTEND
10$:	STY TEMP3
	LDX I,0			;CLEAR RESULT
	LDY I,0
20$:	LSR TEMP1
	BCS 30$			;TIME TO ADD IN
	BNE 40$			;IF NO MORE MULTIPLIER
	RTS

30$:	CLC
	TXA
	ADC TEMP2
	TAX
	TYA
	ADC TEMP3
	TAY
40$:	ASL TEMP2		;2*MULTIPLIER
	ROL TEMP3
	JMP 20$
	.SBTTL	SINE TABLES
	.RADIX	16
;
;TABLES
;
SINES:	.BYTE	0		;0.0
	.BYTE	32		;0.1961
	.BYTE	5F		;0.3714
	.BYTE	9A		;0.6000
	.BYTE	0B5		;0.7071
	.BYTE	0CD		;0.8000
	.BYTE	0EE		;0.9285
	.BYTE	0FB		;0.9806
	.BYTE	0FF		;1.0
;
;	D7 = THRUST X SIGN, D6 = THRUST Y SIGN
;	FOR RESPECTIVE X,Y QUADRANTS
;
SIGNS:	.BYTE	0		;(-X,-Y) QUADRANT
	.BYTE	80		;(X,-Y)
	.BYTE	0C0		;(X,Y)
	.BYTE	40		;(-X,Y)
	.PAGE
	.SBTTL	THRUST TABLES
;
TRSTAB:	.BYTE	00
	.BYTE	2
	.BYTE	5
	.BYTE	8
	.BYTE	0B
	.BYTE	0D
	.BYTE	0F
	.BYTE	10
	.BYTE	11
	.BYTE	12
	.BYTE	13
	.BYTE	14
	.BYTE	16
	.BYTE	18
	.BYTE	1A
	.BYTE	1C
	.BYTE	0FF
	.PAGE
	.SBTTL	LUNARMODULE TABLES
;
SHPUPL:	.BYTE	-18.,12.		;MODULE UPPER LEFT CORNER(S)
	.BYTE	-21.,8.
	.BYTE	-22.,4.
	.BYTE	-23.,-1
	.BYTE	-22.,-5.
	.BYTE	-21.,-8.
	.BYTE	-19.,-13.
	.BYTE	-15.,-16.
	.BYTE	-11.,-18.
	.BYTE	-8.,-21.
	.BYTE	-8.,0
	.BYTE	-7.,-3.
	.BYTE	-7.,-4.
	.BYTE	-6.,-5.
	.BYTE	-8.,0
	.BYTE	-8.,-1
	.BYTE	-8.,-3.
	.BYTE	-7,-4
	.BYTE	-8,0
	.BYTE	-7,-2
	.BYTE	-7,-3
	.BYTE	-6,-4
	.BYTE	-8,0
	.BYTE	-8,-1
	.BYTE	-12.,18.
	.BYTE	-15.,16.
	.BYTE	-19.,13.
	.BYTE	-21.,8
	.BYTE	-22.,5
	.BYTE	-23.,1
	.BYTE	-22.,-4
	.BYTE	-21.,-8.
;
SHPLWL:	.BYTE	-18.,-11.		;MODULE LOWER LEFT CORNER(S)
	.BYTE	-16.,-15.
	.BYTE	-14.,-18.
	.BYTE	-8.,-22.
	.BYTE	-5.,-22.
	.BYTE	-3,-22.
	.BYTE	-19.,-13.
	.BYTE	-15.,-16.
	.BYTE	-9.,-18.
	.BYTE	-8.,-21.
	.BYTE	-3.,-22.
	.BYTE	3.,-22.
	.BYTE	5.,-22.
	.BYTE	8.,-22.
	.BYTE	4.,-18.
	.BYTE	-4,-7.
	.BYTE	-3,-8.
	.BYTE	-1,-8
	.BYTE	1,-8
	.BYTE	-4,-6
	.BYTE	-3,-7
	.BYTE	-2,-7
	.BYTE	0,-9
	.BYTE	1,-8
	.BYTE	-3,-8
	.BYTE	-7,-4
	.BYTE	-7,-6
	.BYTE	-5,-6
	.BYTE	-4,-7
	.BYTE	-3,-7
	.BYTE	-22.,-4
	.BYTE	-21.,-8.
;
SHPLWR:	.BYTE	3,-7.		;MODULE LOWER RIGHT CORNER(S)
	.BYTE	4,-7.
	.BYTE	5,-7.
	.BYTE	6,-5.
	.BYTE	-5,-22.
	.BYTE	-3,-22.
	.BYTE	3,-22.
	.BYTE	8.,-21.
	.BYTE	12.,-18.
	.BYTE	15.,-16.
	.BYTE	19.,-13.
	.BYTE	21.,-8.
	.BYTE	22.,-5
	.BYTE	23.,-1
	.BYTE	22.,4
	.BYTE	16.,-15.
	.BYTE	18.,-12.
	.BYTE	21.,-8.
	.BYTE	22.,-4
	.BYTE	3,-7
	.BYTE	4,-7
	.BYTE	5,-6
	.BYTE	7,-6
	.BYTE	7,-4
	.BYTE	2,-8
	.BYTE	-1,-8
	.BYTE	0,-9
	.BYTE	2,-7
	.BYTE	3,-7
	.BYTE	4,-6
	.BYTE	-1,-8
	.BYTE	1,-8
;
SHPUPR:	.BYTE	8,-2		;MODULE UPPER RIGHT CORNER(S)
	.BYTE	8,-1
	.BYTE	8,0
	.BYTE	7,2
	.BYTE	7,-4
	.BYTE	7,-3
	.BYTE	8,0
	.BYTE	8,1
	.BYTE	12.,-18.
	.BYTE	15.,-16.
	.BYTE	19.,-13.
	.BYTE	21.,-8
	.BYTE	22.,-5
	.BYTE	23.,-1
	.BYTE	22.,4
	.BYTE	21.,8
	.BYTE	18.,-12.
	.BYTE	21.,-8.
	.BYTE	22.,-4
	.BYTE	23.,1
	.BYTE	22.,5
	.BYTE	21.,8
	.BYTE	19.,13.
	.BYTE	15.,16.
	.BYTE	11.,18.
	.BYTE	8,-1
	.BYTE	8,0
	.BYTE	6,-4
	.BYTE	7,-3
	.BYTE	7,-2
	.BYTE	6,-5
	.BYTE	7,-4
;
LNADMJR:.WORD	453C		;LUNAR MAJOR VG RAM HALF SECTIONS
	.WORD	45BC		; 128. ALONG X-AXIS
	.WORD	465E
	.WORD	46B4
;
;	EQUATED LABELS FOR MIN/MAX SHIP POSITIONS & RESET POSITIONS
;
YMIMIN	=256./4		;SHIP Y MINOR SCAPE MIN. (ADJUSTED)
YMIMAX	=660./4		;SHIP Y MINOR SCAPE MAX. (ADJUSTED)
XMAX	=896./4		;SHIP X SCAPE MAX. (ADJUSTED)
XMIN	=128./4		;SHIP X SCAPE MIN. (ADJUSTED)
YMISCR	=520.		;SHIP Y MINOR SCAPE SCROLL POSITION
YMJMIN	=96.		;SHIP Y MAJOR SCAPE MIN.
YMJMAX	=660./4		;SHIP Y MAJOR SCAPE MAX. (ADJUSTED)
MINSTX	=512./4		;SHIP X MINOR SCAPE RESET (ADJUSTED)
MINSTY	=632./4		;SHIP Y MINOR SCAPE RESET (ADJUSTED)
MNSETY	=0A000+632.	;MINOR SCAPE Y LABS RESET POSITION
MINORG	=0A000+24.	;MINOR SCAPE Y LABS ORIGIN POSITION (REFERENCE)
RMJRX	=512./4		;SHIP X MAJOR SCAPE RESET (ADJUSTED)
;
	.SBTTL	INITIALIZATION VALUES
;
;
INTXCUR:.WORD	64.*40		;INITIAL X ADJUSTED POSITION (MODULE)
INTYCUR:.WORD	682.*40		;INITIAL Y ADJUSTED POSITION (MODULE)
INVELX:	.WORD	3200		;INITIAL X VELOCITY
INVELY:	.WORD	10		;INITIAL Y VELOCITY
;
	.SBTTL	CHKSUM #12 (7800 - 7BFF)  [08]
	.BYTE	0
	.END


                                                 